<testsuite name="CHECKPATCH" tests="21">
 <testcase classname="CHECKPATCH.WARNING" name="LONG_LINE">
  <failure type="LONG_LINE">LONG_LINE</failure>
  <system-err>
line over 80 characters&#10;#137: FILE: monit.c:137:&#10;+char *actionnames[] = {&quot;ignore&quot;, &quot;alert&quot;, &quot;restart&quot;, &quot;stop&quot;, &quot;exec&quot;, &quot;unmonitor&quot;, &quot;start&quot;, &quot;monitor&quot;, &quot;&quot;};&#10;&#10;#140: FILE: monit.c:140:&#10;+char *operatornames[] = {&quot;less than&quot;, &quot;greater than&quot;, &quot;equal to&quot;, &quot;not equal to&quot;, &quot;changed&quot;};&#10;&#10;#142: FILE: monit.c:142:&#10;+char *statusnames[] = {&quot;Accessible&quot;, &quot;Accessible&quot;, &quot;Accessible&quot;, &quot;Running&quot;, &quot;Online with all services&quot;, &quot;Running&quot;, &quot;Accessible&quot;, &quot;Status ok&quot;, &quot;UP&quot;};&#10;&#10;#143: FILE: monit.c:143:&#10;+char *servicetypes[] = {&quot;Filesystem&quot;, &quot;Directory&quot;, &quot;File&quot;, &quot;Process&quot;, &quot;Remote Host&quot;, &quot;System&quot;, &quot;Fifo&quot;, &quot;Program&quot;, &quot;Network&quot;};&#10;&#10;#145: FILE: monit.c:145:&#10;+char *icmpnames[] = {&quot;Reply&quot;, &quot;&quot;, &quot;&quot;, &quot;Destination Unreachable&quot;, &quot;Source Quench&quot;, &quot;Redirect&quot;, &quot;&quot;, &quot;&quot;, &quot;Ping&quot;, &quot;&quot;, &quot;&quot;, &quot;Time Exceeded&quot;, &quot;Parameter Problem&quot;, &quot;Timestamp Request&quot;, &quot;Timestamp Reply&quot;, &quot;Information Request&quot;, &quot;Information Reply&quot;, &quot;Address Mask Request&quot;, &quot;Address Mask Reply&quot;};&#10;&#10;#352: FILE: monit.c:352:&#10;+                LogError(&quot;%s stopped -- configuration file parsing error\n&quot;, prog);&#10;&#10;#387: FILE: monit.c:387:&#10;+        Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit reloaded&quot;);&#10;&#10;#416: FILE: monit.c:416:&#10;+                                for (ServiceGroup_T sg = servicegrouplist; sg; sg = sg-&amp;gt;next) {&#10;&#10;#418: FILE: monit.c:418:&#10;+                                                for (list_t m = sg-&amp;gt;members-&amp;gt;head; m; m = m-&amp;gt;next) {&#10;&#10;#420: FILE: monit.c:420:&#10;+                                                        List_append(services, s-&amp;gt;name);&#10;&#10;#427: FILE: monit.c:427:&#10;+                                        LogError(&quot;Group '%s' not found\n&quot;, Run.mygroup);&#10;&#10;#436: FILE: monit.c:436:&#10;+                        errors = exist_daemon() ? control_service_daemon(services, action) : control_service_string(services, action);&#10;&#10;#441: FILE: monit.c:441:&#10;+                        LogError(&quot;Please specify a service name or 'all' after %s\n&quot;, action);&#10;&#10;#468: FILE: monit.c:468:&#10;+                LogError(&quot;Invalid argument -- %s  (-h will show valid arguments)\n&quot;, action);&#10;&#10;#493: FILE: monit.c:493:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_STOP, &quot;Monit %s stopped&quot;, VERSION);&#10;&#10;#516: FILE: monit.c:516:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at [%s]:%d\n&quot;, VERSION, Run.httpd.socket.net.address ? Run.httpd.socket.net.address : &quot;*&quot;, Run.httpd.socket.net.port);&#10;&#10;#518: FILE: monit.c:518:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at %s\n&quot;, VERSION, Run.httpd.socket.unix.path);&#10;&#10;#524: FILE: monit.c:524:&#10;+                        LogInfo(&quot;Monit start delay set -- pause for %ds\n&quot;, Run.startdelay);&#10;&#10;#559: FILE: monit.c:559:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit %s started&quot;, VERSION);&#10;&#10;#571: FILE: monit.c:571:&#10;+                        if (! (Run.flags &amp;amp; Run_ActionPending) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Stopped))&#10;&#10;#628: FILE: monit.c:628:&#10;+                                                f = File_getRealPath(optarg, (char[PATH_MAX]){});&#10;&#10;#631: FILE: monit.c:631:&#10;+                                                      Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));&#10;&#10;#633: FILE: monit.c:633:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not a file&quot;, Str_trunc(f, 80));&#10;&#10;#635: FILE: monit.c:635:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not readable&quot;, Str_trunc(f, 80));&#10;&#10;#644: FILE: monit.c:644:&#10;+                                                LogError(&quot;Option -%c requires a natural number\n&quot;, opt);&#10;&#10;#728: FILE: monit.c:728:&#10;+                                                        LogError(&quot;Option -- %c requires an argument\n&quot;, optopt);&#10;&#10;#733: FILE: monit.c:733:&#10;+                                                        LogError(&quot;Invalid option -- %c  (-h will show valid options)\n&quot;, optopt);&#10;&#10;#851: FILE: monit.c:851:&#10;+                while (! (Run.flags &amp;amp; Run_Stopped) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_DoReload)) {&#10;&#10;#853: FILE: monit.c:853:&#10;+                        struct timespec wait = {.tv_sec = Time_now() + Run.polltime, .tv_nsec = 0};&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="CODE_INDENT">
  <failure type="CODE_INDENT">CODE_INDENT</failure>
  <system-err>
code indent should use tabs where possible&#10;#156: FILE: monit.c:156:&#10;+        Bootstrap(); // Bootstrap libmonit$&#10;&#10;#157: FILE: monit.c:157:&#10;+        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit$&#10;&#10;#158: FILE: monit.c:158:&#10;+        Bootstrap_setErrorHandler(vLogError);$&#10;&#10;#159: FILE: monit.c:159:&#10;+        setlocale(LC_ALL, &quot;C&quot;);$&#10;&#10;#160: FILE: monit.c:160:&#10;+        prog = File_basename(argv[0]);$&#10;&#10;#162: FILE: monit.c:162:&#10;+        Ssl_start();$&#10;&#10;#164: FILE: monit.c:164:&#10;+        init_env();$&#10;&#10;#165: FILE: monit.c:165:&#10;+        handle_options(argc, argv);$&#10;&#10;#166: FILE: monit.c:166:&#10;+        do_init();$&#10;&#10;#167: FILE: monit.c:167:&#10;+        do_action(argv);$&#10;&#10;#168: FILE: monit.c:168:&#10;+        do_exit();$&#10;&#10;#169: FILE: monit.c:169:&#10;+        return 0;$&#10;&#10;#178: FILE: monit.c:178:&#10;+        pid_t pid;$&#10;&#10;#180: FILE: monit.c:180:&#10;+        if ((pid = exist_daemon()) &amp;gt; 0) {$&#10;&#10;#181: FILE: monit.c:181:&#10;+                kill(pid, SIGUSR1);$&#10;&#10;#182: FILE: monit.c:182:&#10;+                LogInfo(&quot;Monit daemon with PID %d awakened\n&quot;, pid);$&#10;&#10;#184: FILE: monit.c:184:&#10;+                return true;$&#10;&#10;#185: FILE: monit.c:185:&#10;+        }$&#10;&#10;#187: FILE: monit.c:187:&#10;+        return false;$&#10;&#10;#195: FILE: monit.c:195:&#10;+        if (State_open()) {$&#10;&#10;#196: FILE: monit.c:196:&#10;+                State_restore();$&#10;&#10;#197: FILE: monit.c:197:&#10;+                validate();$&#10;&#10;#198: FILE: monit.c:198:&#10;+                State_save();$&#10;&#10;#199: FILE: monit.c:199:&#10;+                State_close();$&#10;&#10;#200: FILE: monit.c:200:&#10;+        }$&#10;&#10;#210: FILE: monit.c:210:&#10;+        /*$&#10;&#10;#211: FILE: monit.c:211:&#10;+         * Register interest for the SIGTERM signal,$&#10;&#10;#212: FILE: monit.c:212:&#10;+         * in case we run in daemon mode this signal$&#10;&#10;#213: FILE: monit.c:213:&#10;+         * will terminate a running daemon.$&#10;&#10;#214: FILE: monit.c:214:&#10;+         */$&#10;&#10;#215: FILE: monit.c:215:&#10;+        signal(SIGTERM, do_destroy);$&#10;&#10;#217: FILE: monit.c:217:&#10;+        /*$&#10;&#10;#218: FILE: monit.c:218:&#10;+         * Register interest for the SIGUSER1 signal,$&#10;&#10;#219: FILE: monit.c:219:&#10;+         * in case we run in daemon mode this signal$&#10;&#10;#220: FILE: monit.c:220:&#10;+         * will wakeup a sleeping daemon.$&#10;&#10;#221: FILE: monit.c:221:&#10;+         */$&#10;&#10;#222: FILE: monit.c:222:&#10;+        signal(SIGUSR1, do_wakeup);$&#10;&#10;#224: FILE: monit.c:224:&#10;+        /*$&#10;&#10;#225: FILE: monit.c:225:&#10;+         * Register interest for the SIGINT signal,$&#10;&#10;#226: FILE: monit.c:226:&#10;+         * in case we run as a server but not as a daemon$&#10;&#10;#227: FILE: monit.c:227:&#10;+         * we need to catch this signal if the user pressed$&#10;&#10;#228: FILE: monit.c:228:&#10;+         * CTRL^C in the terminal$&#10;&#10;#229: FILE: monit.c:229:&#10;+         */$&#10;&#10;#230: FILE: monit.c:230:&#10;+        signal(SIGINT, do_destroy);$&#10;&#10;#232: FILE: monit.c:232:&#10;+        /*$&#10;&#10;#233: FILE: monit.c:233:&#10;+         * Register interest for the SIGHUP signal,$&#10;&#10;#234: FILE: monit.c:234:&#10;+         * in case we run in daemon mode this signal$&#10;&#10;#235: FILE: monit.c:235:&#10;+         * will reload the configuration.$&#10;&#10;#236: FILE: monit.c:236:&#10;+         */$&#10;&#10;#237: FILE: monit.c:237:&#10;+        signal(SIGHUP, do_reload);$&#10;&#10;#239: FILE: monit.c:239:&#10;+        /*$&#10;&#10;#240: FILE: monit.c:240:&#10;+         * Register no interest for the SIGPIPE signal,$&#10;&#10;#241: FILE: monit.c:241:&#10;+         */$&#10;&#10;#242: FILE: monit.c:242:&#10;+        signal(SIGPIPE, SIG_IGN);$&#10;&#10;#244: FILE: monit.c:244:&#10;+        /*$&#10;&#10;#245: FILE: monit.c:245:&#10;+         * Initialize the random number generator$&#10;&#10;#246: FILE: monit.c:246:&#10;+         */$&#10;&#10;#247: FILE: monit.c:247:&#10;+        srandom((unsigned)(Time_now() + getpid()));$&#10;&#10;#249: FILE: monit.c:249:&#10;+        /*$&#10;&#10;#250: FILE: monit.c:250:&#10;+         * Initialize the Runtime mutex. This mutex$&#10;&#10;#251: FILE: monit.c:251:&#10;+         * is used to synchronize handling of global$&#10;&#10;#252: FILE: monit.c:252:&#10;+         * service data$&#10;&#10;#253: FILE: monit.c:253:&#10;+         */$&#10;&#10;#254: FILE: monit.c:254:&#10;+        Mutex_init(Run.mutex);$&#10;&#10;#256: FILE: monit.c:256:&#10;+        /*$&#10;&#10;#257: FILE: monit.c:257:&#10;+         * Initialize heartbeat mutex and condition$&#10;&#10;#258: FILE: monit.c:258:&#10;+         */$&#10;&#10;#259: FILE: monit.c:259:&#10;+        Mutex_init(heartbeatMutex);$&#10;&#10;#260: FILE: monit.c:260:&#10;+        Sem_init(heartbeatCond);$&#10;&#10;#262: FILE: monit.c:262:&#10;+        /*$&#10;&#10;#263: FILE: monit.c:263:&#10;+         * Get the position of the control file$&#10;&#10;#264: FILE: monit.c:264:&#10;+         */$&#10;&#10;#265: FILE: monit.c:265:&#10;+        if (! Run.files.control)$&#10;&#10;#266: FILE: monit.c:266:&#10;+                Run.files.control = file_findControlFile();$&#10;&#10;#268: FILE: monit.c:268:&#10;+        /*$&#10;&#10;#269: FILE: monit.c:269:&#10;+         * Initialize the process information gathering interface$&#10;&#10;#270: FILE: monit.c:270:&#10;+         */$&#10;&#10;#271: FILE: monit.c:271:&#10;+        if (init_process_info())$&#10;&#10;#272: FILE: monit.c:272:&#10;+                Run.flags |= Run_ProcessEngineEnabled;$&#10;&#10;#274: FILE: monit.c:274:&#10;+        /*$&#10;&#10;#275: FILE: monit.c:275:&#10;+         * Start the Parser and create the service list. This will also set$&#10;&#10;#276: FILE: monit.c:276:&#10;+         * any Runtime constants defined in the controlfile.$&#10;&#10;#277: FILE: monit.c:277:&#10;+         */$&#10;&#10;#278: FILE: monit.c:278:&#10;+        if (! parse(Run.files.control))$&#10;&#10;#279: FILE: monit.c:279:&#10;+                exit(1);$&#10;&#10;#281: FILE: monit.c:281:&#10;+        /*$&#10;&#10;#282: FILE: monit.c:282:&#10;+         * Initialize the log system$&#10;&#10;#283: FILE: monit.c:283:&#10;+         */$&#10;&#10;#284: FILE: monit.c:284:&#10;+        if (! log_init())$&#10;&#10;#285: FILE: monit.c:285:&#10;+                exit(1);$&#10;&#10;#287: FILE: monit.c:287:&#10;+        /*$&#10;&#10;#288: FILE: monit.c:288:&#10;+         * Did we find any service ?$&#10;&#10;#289: FILE: monit.c:289:&#10;+         */$&#10;&#10;#290: FILE: monit.c:290:&#10;+        if (! servicelist) {$&#10;&#10;#291: FILE: monit.c:291:&#10;+                LogError(&quot;No services has been specified\n&quot;);$&#10;&#10;#292: FILE: monit.c:292:&#10;+                exit(0);$&#10;&#10;#293: FILE: monit.c:293:&#10;+        }$&#10;&#10;#295: FILE: monit.c:295:&#10;+        /*$&#10;&#10;#296: FILE: monit.c:296:&#10;+         * Initialize Runtime file variables$&#10;&#10;#297: FILE: monit.c:297:&#10;+         */$&#10;&#10;#298: FILE: monit.c:298:&#10;+        file_init();$&#10;&#10;#300: FILE: monit.c:300:&#10;+        /*$&#10;&#10;#301: FILE: monit.c:301:&#10;+         * Should we print debug information ?$&#10;&#10;#302: FILE: monit.c:302:&#10;+         */$&#10;&#10;#303: FILE: monit.c:303:&#10;+        if (Run.debug) {$&#10;&#10;#304: FILE: monit.c:304:&#10;+                Util_printRunList();$&#10;&#10;#305: FILE: monit.c:305:&#10;+                Util_printServiceList();$&#10;&#10;#306: FILE: monit.c:306:&#10;+        }$&#10;&#10;#308: FILE: monit.c:308:&#10;+        /*$&#10;&#10;#309: FILE: monit.c:309:&#10;+         * Reap any stray child processes we may have created$&#10;&#10;#310: FILE: monit.c:310:&#10;+         */$&#10;&#10;#311: FILE: monit.c:311:&#10;+        atexit(waitforchildren);$&#10;&#10;#320: FILE: monit.c:320:&#10;+        LogInfo(&quot;Awakened by the SIGHUP signal\n&quot;$&#10;&#10;#321: FILE: monit.c:321:&#10;+                &quot;Reinitializing Monit - Control file '%s'\n&quot;,$&#10;&#10;#322: FILE: monit.c:322:&#10;+                Run.files.control);$&#10;&#10;#324: FILE: monit.c:324:&#10;+        /* Wait non-blocking for any children that has exited. Since we$&#10;&#10;#325: FILE: monit.c:325:&#10;+         reinitialize any information about children we have setup to wait$&#10;&#10;#326: FILE: monit.c:326:&#10;+         for will be lost. This may create zombie processes until Monit$&#10;&#10;#327: FILE: monit.c:327:&#10;+         itself exit. However, Monit will wait on all children that has exited$&#10;&#10;#328: FILE: monit.c:328:&#10;+         before it ifself exit. TODO: Later refactored versions will use a$&#10;&#10;#329: FILE: monit.c:329:&#10;+         globale process table which a sigchld handler can check */$&#10;&#10;#330: FILE: monit.c:330:&#10;+        waitforchildren();$&#10;&#10;#332: FILE: monit.c:332:&#10;+        if (Run.mmonits &amp;amp;&amp;amp; heartbeatRunning) {$&#10;&#10;#333: FILE: monit.c:333:&#10;+                Sem_signal(heartbeatCond);$&#10;&#10;#334: FILE: monit.c:334:&#10;+                Thread_join(heartbeatThread);$&#10;&#10;#335: FILE: monit.c:335:&#10;+                heartbeatRunning = false;$&#10;&#10;#336: FILE: monit.c:336:&#10;+        }$&#10;&#10;#338: FILE: monit.c:338:&#10;+        Run.flags &amp;amp;= ~Run_DoReload;$&#10;&#10;#340: FILE: monit.c:340:&#10;+        /* Stop http interface */$&#10;&#10;#341: FILE: monit.c:341:&#10;+        if (Run.httpd.flags &amp;amp; Httpd_Net || Run.httpd.flags &amp;amp; Httpd_Unix)$&#10;&#10;#342: FILE: monit.c:342:&#10;+                monit_http(Httpd_Stop);$&#10;&#10;#344: FILE: monit.c:344:&#10;+        /* Save the current state (no changes are possible now since the http thread is stopped) */$&#10;&#10;#345: FILE: monit.c:345:&#10;+        State_save();$&#10;&#10;#346: FILE: monit.c:346:&#10;+        State_close();$&#10;&#10;#348: FILE: monit.c:348:&#10;+        /* Run the garbage collector */$&#10;&#10;#349: FILE: monit.c:349:&#10;+        gc();$&#10;&#10;#351: FILE: monit.c:351:&#10;+        if (! parse(Run.files.control)) {$&#10;&#10;#352: FILE: monit.c:352:&#10;+                LogError(&quot;%s stopped -- configuration file parsing error\n&quot;, prog);$&#10;&#10;#353: FILE: monit.c:353:&#10;+                exit(1);$&#10;&#10;#354: FILE: monit.c:354:&#10;+        }$&#10;&#10;#356: FILE: monit.c:356:&#10;+        /* Close the current log */$&#10;&#10;#357: FILE: monit.c:357:&#10;+        log_close();$&#10;&#10;#359: FILE: monit.c:359:&#10;+        /* Reinstall the log system */$&#10;&#10;#360: FILE: monit.c:360:&#10;+        if (! log_init())$&#10;&#10;#361: FILE: monit.c:361:&#10;+                exit(1);$&#10;&#10;#363: FILE: monit.c:363:&#10;+        /* Did we find any services ?  */$&#10;&#10;#364: FILE: monit.c:364:&#10;+        if (! servicelist) {$&#10;&#10;#365: FILE: monit.c:365:&#10;+                LogError(&quot;No services has been specified\n&quot;);$&#10;&#10;#366: FILE: monit.c:366:&#10;+                exit(0);$&#10;&#10;#367: FILE: monit.c:367:&#10;+        }$&#10;&#10;#369: FILE: monit.c:369:&#10;+        /* Reinitialize Runtime file variables */$&#10;&#10;#370: FILE: monit.c:370:&#10;+        file_init();$&#10;&#10;#372: FILE: monit.c:372:&#10;+        if (! file_createPidFile(Run.files.pid)) {$&#10;&#10;#373: FILE: monit.c:373:&#10;+                LogError(&quot;%s stopped -- cannot create a pid file\n&quot;, prog);$&#10;&#10;#374: FILE: monit.c:374:&#10;+                exit(1);$&#10;&#10;#375: FILE: monit.c:375:&#10;+        }$&#10;&#10;#377: FILE: monit.c:377:&#10;+        /* Update service data from the state repository */$&#10;&#10;#378: FILE: monit.c:378:&#10;+        if (! State_open())$&#10;&#10;#379: FILE: monit.c:379:&#10;+                exit(1);$&#10;&#10;#380: FILE: monit.c:380:&#10;+        State_restore();$&#10;&#10;#382: FILE: monit.c:382:&#10;+        /* Start http interface */$&#10;&#10;#383: FILE: monit.c:383:&#10;+        if (can_http())$&#10;&#10;#384: FILE: monit.c:384:&#10;+                monit_http(Httpd_Start);$&#10;&#10;#386: FILE: monit.c:386:&#10;+        /* send the monit startup notification */$&#10;&#10;#387: FILE: monit.c:387:&#10;+        Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit reloaded&quot;);$&#10;&#10;#389: FILE: monit.c:389:&#10;+        if (Run.mmonits) {$&#10;&#10;#390: FILE: monit.c:390:&#10;+                Thread_create(heartbeatThread, heartbeat, NULL);$&#10;&#10;#391: FILE: monit.c:391:&#10;+                heartbeatRunning = true;$&#10;&#10;#392: FILE: monit.c:392:&#10;+        }$&#10;&#10;#400: FILE: monit.c:400:&#10;+        char *action = args[optind];$&#10;&#10;#401: FILE: monit.c:401:&#10;+        char *service = args[++optind];$&#10;&#10;#403: FILE: monit.c:403:&#10;+        Run.flags |= Run_Once;$&#10;&#10;#405: FILE: monit.c:405:&#10;+        if (! action) {$&#10;&#10;#406: FILE: monit.c:406:&#10;+                do_default();$&#10;&#10;#407: FILE: monit.c:407:&#10;+        } else if (IS(action, &quot;start&quot;)     ||$&#10;&#10;#408: FILE: monit.c:408:&#10;+                   IS(action, &quot;stop&quot;)      ||$&#10;&#10;#409: FILE: monit.c:409:&#10;+                   IS(action, &quot;monitor&quot;)   ||$&#10;&#10;#410: FILE: monit.c:410:&#10;+                   IS(action, &quot;unmonitor&quot;) ||$&#10;&#10;#411: FILE: monit.c:411:&#10;+                   IS(action, &quot;restart&quot;)) {$&#10;&#10;#412: FILE: monit.c:412:&#10;+                if (Run.mygroup || service) {$&#10;&#10;#413: FILE: monit.c:413:&#10;+                        int errors = 0;$&#10;&#10;#414: FILE: monit.c:414:&#10;+                        List_T services = List_new();$&#10;&#10;#415: FILE: monit.c:415:&#10;+                        if (Run.mygroup) {$&#10;&#10;#416: FILE: monit.c:416:&#10;+                                for (ServiceGroup_T sg = servicegrouplist; sg; sg = sg-&amp;gt;next) {$&#10;&#10;#417: FILE: monit.c:417:&#10;+                                        if (IS(Run.mygroup, sg-&amp;gt;name)) {$&#10;&#10;#418: FILE: monit.c:418:&#10;+                                                for (list_t m = sg-&amp;gt;members-&amp;gt;head; m; m = m-&amp;gt;next) {$&#10;&#10;#419: FILE: monit.c:419:&#10;+                                                        Service_T s = m-&amp;gt;e;$&#10;&#10;#420: FILE: monit.c:420:&#10;+                                                        List_append(services, s-&amp;gt;name);$&#10;&#10;#421: FILE: monit.c:421:&#10;+                                                }$&#10;&#10;#422: FILE: monit.c:422:&#10;+                                                break;$&#10;&#10;#423: FILE: monit.c:423:&#10;+                                        }$&#10;&#10;#424: FILE: monit.c:424:&#10;+                                }$&#10;&#10;#425: FILE: monit.c:425:&#10;+                                if (List_length(services) == 0) {$&#10;&#10;#426: FILE: monit.c:426:&#10;+                                        List_free(&amp;amp;services);$&#10;&#10;#427: FILE: monit.c:427:&#10;+                                        LogError(&quot;Group '%s' not found\n&quot;, Run.mygroup);$&#10;&#10;#428: FILE: monit.c:428:&#10;+                                        exit(1);$&#10;&#10;#429: FILE: monit.c:429:&#10;+                                }$&#10;&#10;#430: FILE: monit.c:430:&#10;+                        } else if (IS(service, &quot;all&quot;)) {$&#10;&#10;#431: FILE: monit.c:431:&#10;+                                for (Service_T s = servicelist; s; s = s-&amp;gt;next)$&#10;&#10;#432: FILE: monit.c:432:&#10;+                                        List_append(services, s-&amp;gt;name);$&#10;&#10;#433: FILE: monit.c:433:&#10;+                        } else {$&#10;&#10;#434: FILE: monit.c:434:&#10;+                                List_append(services, service);$&#10;&#10;#435: FILE: monit.c:435:&#10;+                        }$&#10;&#10;#436: FILE: monit.c:436:&#10;+                        errors = exist_daemon() ? control_service_daemon(services, action) : control_service_string(services, action);$&#10;&#10;#437: FILE: monit.c:437:&#10;+                        List_free(&amp;amp;services);$&#10;&#10;#438: FILE: monit.c:438:&#10;+                        if (errors)$&#10;&#10;#439: FILE: monit.c:439:&#10;+                                exit(1);$&#10;&#10;#440: FILE: monit.c:440:&#10;+                } else {$&#10;&#10;#441: FILE: monit.c:441:&#10;+                        LogError(&quot;Please specify a service name or 'all' after %s\n&quot;, action);$&#10;&#10;#442: FILE: monit.c:442:&#10;+                        exit(1);$&#10;&#10;#443: FILE: monit.c:443:&#10;+                }$&#10;&#10;#444: FILE: monit.c:444:&#10;+        } else if (IS(action, &quot;reload&quot;)) {$&#10;&#10;#445: FILE: monit.c:445:&#10;+                LogInfo(&quot;Reinitializing %s daemon\n&quot;, prog);$&#10;&#10;#446: FILE: monit.c:446:&#10;+                kill_daemon(SIGHUP);$&#10;&#10;#447: FILE: monit.c:447:&#10;+        } else if (IS(action, &quot;status&quot;)) {$&#10;&#10;#448: FILE: monit.c:448:&#10;+                if (! status(LEVEL_NAME_FULL, Run.mygroup, service))$&#10;&#10;#449: FILE: monit.c:449:&#10;+                        exit(1);$&#10;&#10;#450: FILE: monit.c:450:&#10;+        } else if (IS(action, &quot;summary&quot;)) {$&#10;&#10;#451: FILE: monit.c:451:&#10;+                if (! status(LEVEL_NAME_SUMMARY, Run.mygroup, service))$&#10;&#10;#452: FILE: monit.c:452:&#10;+                        exit(1);$&#10;&#10;#453: FILE: monit.c:453:&#10;+        } else if (IS(action, &quot;procmatch&quot;)) {$&#10;&#10;#454: FILE: monit.c:454:&#10;+                if (! service) {$&#10;&#10;#455: FILE: monit.c:455:&#10;+                        printf(&quot;Invalid syntax - usage: procmatch \&quot;&amp;lt;pattern&amp;gt;\&quot;\n&quot;);$&#10;&#10;#456: FILE: monit.c:456:&#10;+                        exit(1);$&#10;&#10;#457: FILE: monit.c:457:&#10;+                }$&#10;&#10;#458: FILE: monit.c:458:&#10;+                process_testmatch(service);$&#10;&#10;#459: FILE: monit.c:459:&#10;+        } else if (IS(action, &quot;quit&quot;)) {$&#10;&#10;#460: FILE: monit.c:460:&#10;+                kill_daemon(SIGTERM);$&#10;&#10;#461: FILE: monit.c:461:&#10;+        } else if (IS(action, &quot;validate&quot;)) {$&#10;&#10;#462: FILE: monit.c:462:&#10;+                if (do_wakeupcall())$&#10;&#10;#463: FILE: monit.c:463:&#10;+                        status(LEVEL_NAME_FULL, Run.mygroup, service);$&#10;&#10;#464: FILE: monit.c:464:&#10;+                else$&#10;&#10;#465: FILE: monit.c:465:&#10;+                        _validateOnce();$&#10;&#10;#466: FILE: monit.c:466:&#10;+                exit(1);$&#10;&#10;#467: FILE: monit.c:467:&#10;+        } else {$&#10;&#10;#468: FILE: monit.c:468:&#10;+                LogError(&quot;Invalid argument -- %s  (-h will show valid arguments)\n&quot;, action);$&#10;&#10;#469: FILE: monit.c:469:&#10;+                exit(1);$&#10;&#10;#470: FILE: monit.c:470:&#10;+        }$&#10;&#10;#478: FILE: monit.c:478:&#10;+        set_signal_block();$&#10;&#10;#479: FILE: monit.c:479:&#10;+        Run.flags |= Run_Stopped;$&#10;&#10;#480: FILE: monit.c:480:&#10;+        if ((Run.flags &amp;amp; Run_Daemon) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Once)) {$&#10;&#10;#481: FILE: monit.c:481:&#10;+                if (can_http())$&#10;&#10;#482: FILE: monit.c:482:&#10;+                        monit_http(Httpd_Stop);$&#10;&#10;#484: FILE: monit.c:484:&#10;+                if (Run.mmonits &amp;amp;&amp;amp; heartbeatRunning) {$&#10;&#10;#485: FILE: monit.c:485:&#10;+                        Sem_signal(heartbeatCond);$&#10;&#10;#486: FILE: monit.c:486:&#10;+                        Thread_join(heartbeatThread);$&#10;&#10;#487: FILE: monit.c:487:&#10;+                        heartbeatRunning = false;$&#10;&#10;#488: FILE: monit.c:488:&#10;+                }$&#10;&#10;#490: FILE: monit.c:490:&#10;+                LogInfo(&quot;Monit daemon with pid [%d] stopped\n&quot;, (int)getpid());$&#10;&#10;#492: FILE: monit.c:492:&#10;+                /* send the monit stop notification */$&#10;&#10;#493: FILE: monit.c:493:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_STOP, &quot;Monit %s stopped&quot;, VERSION);$&#10;&#10;#494: FILE: monit.c:494:&#10;+        }$&#10;&#10;#495: FILE: monit.c:495:&#10;+        gc();$&#10;&#10;#497: FILE: monit.c:497:&#10;+        Ssl_stop();$&#10;&#10;#499: FILE: monit.c:499:&#10;+        exit(0);$&#10;&#10;#509: FILE: monit.c:509:&#10;+        if (Run.flags &amp;amp; Run_Daemon) {$&#10;&#10;#510: FILE: monit.c:510:&#10;+                if (do_wakeupcall())$&#10;&#10;#511: FILE: monit.c:511:&#10;+                        exit(0);$&#10;&#10;#513: FILE: monit.c:513:&#10;+                Run.flags &amp;amp;= ~Run_Once;$&#10;&#10;#514: FILE: monit.c:514:&#10;+                if (can_http()) {$&#10;&#10;#515: FILE: monit.c:515:&#10;+                        if (Run.httpd.flags &amp;amp; Httpd_Net)$&#10;&#10;#516: FILE: monit.c:516:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at [%s]:%d\n&quot;, VERSION, Run.httpd.socket.net.address ? Run.httpd.socket.net.address : &quot;*&quot;, Run.httpd.socket.net.port);$&#10;&#10;#517: FILE: monit.c:517:&#10;+                        else if (Run.httpd.flags &amp;amp; Httpd_Unix)$&#10;&#10;#518: FILE: monit.c:518:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at %s\n&quot;, VERSION, Run.httpd.socket.unix.path);$&#10;&#10;#519: FILE: monit.c:519:&#10;+                } else {$&#10;&#10;#520: FILE: monit.c:520:&#10;+                        LogInfo(&quot;Starting Monit %s daemon\n&quot;, VERSION);$&#10;&#10;#521: FILE: monit.c:521:&#10;+                }$&#10;&#10;#523: FILE: monit.c:523:&#10;+                if (Run.startdelay)$&#10;&#10;#524: FILE: monit.c:524:&#10;+                        LogInfo(&quot;Monit start delay set -- pause for %ds\n&quot;, Run.startdelay);$&#10;&#10;#526: FILE: monit.c:526:&#10;+                if (! (Run.flags &amp;amp; Run_Foreground))$&#10;&#10;#527: FILE: monit.c:527:&#10;+                        daemonize();$&#10;&#10;#528: FILE: monit.c:528:&#10;+                else if (! Run.debug)$&#10;&#10;#529: FILE: monit.c:529:&#10;+                        Util_redirectStdFds();$&#10;&#10;#531: FILE: monit.c:531:&#10;+                if (! file_createPidFile(Run.files.pid)) {$&#10;&#10;#532: FILE: monit.c:532:&#10;+                        LogError(&quot;Monit daemon died\n&quot;);$&#10;&#10;#533: FILE: monit.c:533:&#10;+                        exit(1);$&#10;&#10;#534: FILE: monit.c:534:&#10;+                }$&#10;&#10;#536: FILE: monit.c:536:&#10;+                if (! State_open())$&#10;&#10;#537: FILE: monit.c:537:&#10;+                        exit(1);$&#10;&#10;#538: FILE: monit.c:538:&#10;+                State_restore();$&#10;&#10;#540: FILE: monit.c:540:&#10;+                atexit(file_finalize);$&#10;&#10;#542: FILE: monit.c:542:&#10;+                if (Run.startdelay) {$&#10;&#10;#543: FILE: monit.c:543:&#10;+                        time_t now = Time_now();$&#10;&#10;#544: FILE: monit.c:544:&#10;+                        time_t delay = now + Run.startdelay;$&#10;&#10;#546: FILE: monit.c:546:&#10;+                        /* sleep can be interrupted by signal =&amp;gt; make sure we paused long enough */$&#10;&#10;#547: FILE: monit.c:547:&#10;+                        while (now &amp;lt; delay) {$&#10;&#10;#548: FILE: monit.c:548:&#10;+                                sleep((unsigned int)(delay - now));$&#10;&#10;#549: FILE: monit.c:549:&#10;+                                if (Run.flags &amp;amp; Run_Stopped)$&#10;&#10;#550: FILE: monit.c:550:&#10;+                                        do_exit();$&#10;&#10;#551: FILE: monit.c:551:&#10;+                                now = Time_now();$&#10;&#10;#552: FILE: monit.c:552:&#10;+                        }$&#10;&#10;#553: FILE: monit.c:553:&#10;+                }$&#10;&#10;#555: FILE: monit.c:555:&#10;+                if (can_http())$&#10;&#10;#556: FILE: monit.c:556:&#10;+                        monit_http(Httpd_Start);$&#10;&#10;#558: FILE: monit.c:558:&#10;+                /* send the monit startup notification */$&#10;&#10;#559: FILE: monit.c:559:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit %s started&quot;, VERSION);$&#10;&#10;#561: FILE: monit.c:561:&#10;+                if (Run.mmonits) {$&#10;&#10;#562: FILE: monit.c:562:&#10;+                        Thread_create(heartbeatThread, heartbeat, NULL);$&#10;&#10;#563: FILE: monit.c:563:&#10;+                        heartbeatRunning = true;$&#10;&#10;#564: FILE: monit.c:564:&#10;+                }$&#10;&#10;#566: FILE: monit.c:566:&#10;+                while (true) {$&#10;&#10;#567: FILE: monit.c:567:&#10;+                        validate();$&#10;&#10;#568: FILE: monit.c:568:&#10;+                        State_save();$&#10;&#10;#570: FILE: monit.c:570:&#10;+                        /* In the case that there is no pending action then sleep */$&#10;&#10;#571: FILE: monit.c:571:&#10;+                        if (! (Run.flags &amp;amp; Run_ActionPending) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Stopped))$&#10;&#10;#572: FILE: monit.c:572:&#10;+                                sleep(Run.polltime);$&#10;&#10;#574: FILE: monit.c:574:&#10;+                        if (Run.flags &amp;amp; Run_DoWakeup) {$&#10;&#10;#575: FILE: monit.c:575:&#10;+                                Run.flags &amp;amp;= ~Run_DoWakeup;$&#10;&#10;#576: FILE: monit.c:576:&#10;+                                LogInfo(&quot;Awakened by User defined signal 1\n&quot;);$&#10;&#10;#577: FILE: monit.c:577:&#10;+                        }$&#10;&#10;#579: FILE: monit.c:579:&#10;+                        if (Run.flags &amp;amp; Run_Stopped)$&#10;&#10;#580: FILE: monit.c:580:&#10;+                                do_exit();$&#10;&#10;#581: FILE: monit.c:581:&#10;+                        else if (Run.flags &amp;amp; Run_DoReload)$&#10;&#10;#582: FILE: monit.c:582:&#10;+                                do_reinit();$&#10;&#10;#583: FILE: monit.c:583:&#10;+                }$&#10;&#10;#584: FILE: monit.c:584:&#10;+        } else {$&#10;&#10;#585: FILE: monit.c:585:&#10;+                _validateOnce();$&#10;&#10;#586: FILE: monit.c:586:&#10;+        }$&#10;&#10;#595: FILE: monit.c:595:&#10;+        int opt;$&#10;&#10;#596: FILE: monit.c:596:&#10;+        int deferred_opt = 0;$&#10;&#10;#597: FILE: monit.c:597:&#10;+        opterr = 0;$&#10;&#10;#598: FILE: monit.c:598:&#10;+        Run.mygroup = NULL;$&#10;&#10;#599: FILE: monit.c:599:&#10;+        const char *shortopts = &quot;c:d:g:l:p:s:HIirtvVh&quot;;$&#10;&#10;#601: FILE: monit.c:601:&#10;+        struct option longopts[] = {$&#10;&#10;#602: FILE: monit.c:602:&#10;+                {&quot;conf&quot;,        required_argument,      NULL,   'c'},$&#10;&#10;#603: FILE: monit.c:603:&#10;+                {&quot;daemon&quot;,      required_argument,      NULL,   'd'},$&#10;&#10;#604: FILE: monit.c:604:&#10;+                {&quot;group&quot;,       required_argument,      NULL,   'g'},$&#10;&#10;#605: FILE: monit.c:605:&#10;+                {&quot;logfile&quot;,     required_argument,      NULL,   'l'},$&#10;&#10;#606: FILE: monit.c:606:&#10;+                {&quot;pidfile&quot;,     required_argument,      NULL,   'p'},$&#10;&#10;#607: FILE: monit.c:607:&#10;+                {&quot;statefile&quot;,   required_argument,      NULL,   's'},$&#10;&#10;#608: FILE: monit.c:608:&#10;+                {&quot;hash&quot;,        optional_argument,      NULL,   'H'},$&#10;&#10;#609: FILE: monit.c:609:&#10;+                {&quot;interactive&quot;, no_argument,            NULL,   'I'},$&#10;&#10;#610: FILE: monit.c:610:&#10;+                {&quot;id&quot;,          no_argument,            NULL,   'i'},$&#10;&#10;#611: FILE: monit.c:611:&#10;+                {&quot;resetid&quot;,     no_argument,            NULL,   'r'},$&#10;&#10;#612: FILE: monit.c:612:&#10;+                {&quot;test&quot;,        no_argument,            NULL,   't'},$&#10;&#10;#613: FILE: monit.c:613:&#10;+                {&quot;verbose&quot;,     no_argument,            NULL,   'v'},$&#10;&#10;#614: FILE: monit.c:614:&#10;+                {&quot;version&quot;,     no_argument,            NULL,   'V'},$&#10;&#10;#615: FILE: monit.c:615:&#10;+                {&quot;help&quot;,        no_argument,            NULL,   'h'},$&#10;&#10;#616: FILE: monit.c:616:&#10;+                {0}$&#10;&#10;#617: FILE: monit.c:617:&#10;+        };$&#10;&#10;#618: FILE: monit.c:618:&#10;+        while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)$&#10;&#10;#620: FILE: monit.c:620:&#10;+                while ((opt = getopt(argc, argv, shortopts)) != -1)$&#10;&#10;#622: FILE: monit.c:622:&#10;+                {$&#10;&#10;#623: FILE: monit.c:623:&#10;+                        switch (opt) {$&#10;&#10;#624: FILE: monit.c:624:&#10;+                                case 'c':$&#10;&#10;#625: FILE: monit.c:625:&#10;+                                {$&#10;&#10;#626: FILE: monit.c:626:&#10;+                                        char *f = optarg;$&#10;&#10;#627: FILE: monit.c:627:&#10;+                                        if (f[0] != SEPARATOR_CHAR)$&#10;&#10;#628: FILE: monit.c:628:&#10;+                                                f = File_getRealPath(optarg, (char[PATH_MAX]){});$&#10;&#10;#629: FILE: monit.c:629:&#10;+                                        if (! f)$&#10;&#10;#630: FILE: monit.c:630:&#10;+                                                THROW(AssertException, &quot;The control file '%s' does not exist at %s&quot;,$&#10;&#10;#631: FILE: monit.c:631:&#10;+                                                      Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));$&#10;&#10;#632: FILE: monit.c:632:&#10;+                                        if (! File_isFile(f))$&#10;&#10;#633: FILE: monit.c:633:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not a file&quot;, Str_trunc(f, 80));$&#10;&#10;#634: FILE: monit.c:634:&#10;+                                        if (! File_isReadable(f))$&#10;&#10;#635: FILE: monit.c:635:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not readable&quot;, Str_trunc(f, 80));$&#10;&#10;#636: FILE: monit.c:636:&#10;+                                        Run.files.control = Str_dup(f);$&#10;&#10;#637: FILE: monit.c:637:&#10;+                                        break;$&#10;&#10;#638: FILE: monit.c:638:&#10;+                                }$&#10;&#10;#639: FILE: monit.c:639:&#10;+                                case 'd':$&#10;&#10;#640: FILE: monit.c:640:&#10;+                                {$&#10;&#10;#641: FILE: monit.c:641:&#10;+                                        Run.flags |= Run_Daemon;$&#10;&#10;#642: FILE: monit.c:642:&#10;+                                        sscanf(optarg, &quot;%d&quot;, &amp;amp;Run.polltime);$&#10;&#10;#643: FILE: monit.c:643:&#10;+                                        if (Run.polltime &amp;lt; 1) {$&#10;&#10;#644: FILE: monit.c:644:&#10;+                                                LogError(&quot;Option -%c requires a natural number\n&quot;, opt);$&#10;&#10;#645: FILE: monit.c:645:&#10;+                                                exit(1);$&#10;&#10;#646: FILE: monit.c:646:&#10;+                                        }$&#10;&#10;#647: FILE: monit.c:647:&#10;+                                        break;$&#10;&#10;#648: FILE: monit.c:648:&#10;+                                }$&#10;&#10;#649: FILE: monit.c:649:&#10;+                                case 'g':$&#10;&#10;#650: FILE: monit.c:650:&#10;+                                {$&#10;&#10;#651: FILE: monit.c:651:&#10;+                                        Run.mygroup = Str_dup(optarg);$&#10;&#10;#652: FILE: monit.c:652:&#10;+                                        break;$&#10;&#10;#653: FILE: monit.c:653:&#10;+                                }$&#10;&#10;#654: FILE: monit.c:654:&#10;+                                case 'l':$&#10;&#10;#655: FILE: monit.c:655:&#10;+                                {$&#10;&#10;#656: FILE: monit.c:656:&#10;+                                        Run.files.log = Str_dup(optarg);$&#10;&#10;#657: FILE: monit.c:657:&#10;+                                        if (IS(Run.files.log, &quot;syslog&quot;))$&#10;&#10;#658: FILE: monit.c:658:&#10;+                                                Run.flags |= Run_UseSyslog;$&#10;&#10;#659: FILE: monit.c:659:&#10;+                                        Run.flags |= Run_Log;$&#10;&#10;#660: FILE: monit.c:660:&#10;+                                        break;$&#10;&#10;#661: FILE: monit.c:661:&#10;+                                }$&#10;&#10;#662: FILE: monit.c:662:&#10;+                                case 'p':$&#10;&#10;#663: FILE: monit.c:663:&#10;+                                {$&#10;&#10;#664: FILE: monit.c:664:&#10;+                                        Run.files.pid = Str_dup(optarg);$&#10;&#10;#665: FILE: monit.c:665:&#10;+                                        break;$&#10;&#10;#666: FILE: monit.c:666:&#10;+                                }$&#10;&#10;#667: FILE: monit.c:667:&#10;+                                case 's':$&#10;&#10;#668: FILE: monit.c:668:&#10;+                                {$&#10;&#10;#669: FILE: monit.c:669:&#10;+                                        Run.files.state = Str_dup(optarg);$&#10;&#10;#670: FILE: monit.c:670:&#10;+                                        break;$&#10;&#10;#671: FILE: monit.c:671:&#10;+                                }$&#10;&#10;#672: FILE: monit.c:672:&#10;+                                case 'I':$&#10;&#10;#673: FILE: monit.c:673:&#10;+                                {$&#10;&#10;#674: FILE: monit.c:674:&#10;+                                        Run.flags |= Run_Foreground;$&#10;&#10;#675: FILE: monit.c:675:&#10;+                                        break;$&#10;&#10;#676: FILE: monit.c:676:&#10;+                                }$&#10;&#10;#677: FILE: monit.c:677:&#10;+                                case 'i':$&#10;&#10;#678: FILE: monit.c:678:&#10;+                                {$&#10;&#10;#679: FILE: monit.c:679:&#10;+                                        deferred_opt = 'i';$&#10;&#10;#680: FILE: monit.c:680:&#10;+                                        break;$&#10;&#10;#681: FILE: monit.c:681:&#10;+                                }$&#10;&#10;#682: FILE: monit.c:682:&#10;+                                case 'r':$&#10;&#10;#683: FILE: monit.c:683:&#10;+                                {$&#10;&#10;#684: FILE: monit.c:684:&#10;+                                        deferred_opt = 'r';$&#10;&#10;#685: FILE: monit.c:685:&#10;+                                        break;$&#10;&#10;#686: FILE: monit.c:686:&#10;+                                }$&#10;&#10;#687: FILE: monit.c:687:&#10;+                                case 't':$&#10;&#10;#688: FILE: monit.c:688:&#10;+                                {$&#10;&#10;#689: FILE: monit.c:689:&#10;+                                        deferred_opt = 't';$&#10;&#10;#690: FILE: monit.c:690:&#10;+                                        break;$&#10;&#10;#691: FILE: monit.c:691:&#10;+                                }$&#10;&#10;#692: FILE: monit.c:692:&#10;+                                case 'v':$&#10;&#10;#693: FILE: monit.c:693:&#10;+                                {$&#10;&#10;#694: FILE: monit.c:694:&#10;+                                        Run.debug++;$&#10;&#10;#695: FILE: monit.c:695:&#10;+                                        break;$&#10;&#10;#696: FILE: monit.c:696:&#10;+                                }$&#10;&#10;#697: FILE: monit.c:697:&#10;+                                case 'H':$&#10;&#10;#698: FILE: monit.c:698:&#10;+                                {$&#10;&#10;#699: FILE: monit.c:699:&#10;+                                        if (argc &amp;gt; optind)$&#10;&#10;#700: FILE: monit.c:700:&#10;+                                                Util_printHash(argv[optind]);$&#10;&#10;#701: FILE: monit.c:701:&#10;+                                        else$&#10;&#10;#702: FILE: monit.c:702:&#10;+                                                Util_printHash(NULL);$&#10;&#10;#703: FILE: monit.c:703:&#10;+                                        exit(0);$&#10;&#10;#704: FILE: monit.c:704:&#10;+                                        break;$&#10;&#10;#705: FILE: monit.c:705:&#10;+                                }$&#10;&#10;#706: FILE: monit.c:706:&#10;+                                case 'V':$&#10;&#10;#707: FILE: monit.c:707:&#10;+                                {$&#10;&#10;#708: FILE: monit.c:708:&#10;+                                        version();$&#10;&#10;#709: FILE: monit.c:709:&#10;+                                        exit(0);$&#10;&#10;#710: FILE: monit.c:710:&#10;+                                        break;$&#10;&#10;#711: FILE: monit.c:711:&#10;+                                }$&#10;&#10;#712: FILE: monit.c:712:&#10;+                                case 'h':$&#10;&#10;#713: FILE: monit.c:713:&#10;+                                {$&#10;&#10;#714: FILE: monit.c:714:&#10;+                                        help();$&#10;&#10;#715: FILE: monit.c:715:&#10;+                                        exit(0);$&#10;&#10;#716: FILE: monit.c:716:&#10;+                                        break;$&#10;&#10;#717: FILE: monit.c:717:&#10;+                                }$&#10;&#10;#718: FILE: monit.c:718:&#10;+                                case '?':$&#10;&#10;#719: FILE: monit.c:719:&#10;+                                {$&#10;&#10;#720: FILE: monit.c:720:&#10;+                                        switch (optopt) {$&#10;&#10;#721: FILE: monit.c:721:&#10;+                                                case 'c':$&#10;&#10;#722: FILE: monit.c:722:&#10;+                                                case 'd':$&#10;&#10;#723: FILE: monit.c:723:&#10;+                                                case 'g':$&#10;&#10;#724: FILE: monit.c:724:&#10;+                                                case 'l':$&#10;&#10;#725: FILE: monit.c:725:&#10;+                                                case 'p':$&#10;&#10;#726: FILE: monit.c:726:&#10;+                                                case 's':$&#10;&#10;#727: FILE: monit.c:727:&#10;+                                                {$&#10;&#10;#728: FILE: monit.c:728:&#10;+                                                        LogError(&quot;Option -- %c requires an argument\n&quot;, optopt);$&#10;&#10;#729: FILE: monit.c:729:&#10;+                                                        break;$&#10;&#10;#730: FILE: monit.c:730:&#10;+                                                }$&#10;&#10;#731: FILE: monit.c:731:&#10;+                                                default:$&#10;&#10;#732: FILE: monit.c:732:&#10;+                                                {$&#10;&#10;#733: FILE: monit.c:733:&#10;+                                                        LogError(&quot;Invalid option -- %c  (-h will show valid options)\n&quot;, optopt);$&#10;&#10;#734: FILE: monit.c:734:&#10;+                                                }$&#10;&#10;#735: FILE: monit.c:735:&#10;+                                        }$&#10;&#10;#736: FILE: monit.c:736:&#10;+                                        exit(1);$&#10;&#10;#737: FILE: monit.c:737:&#10;+                                }$&#10;&#10;#738: FILE: monit.c:738:&#10;+                        }$&#10;&#10;#739: FILE: monit.c:739:&#10;+                }$&#10;&#10;#740: FILE: monit.c:740:&#10;+        /* Handle deferred options to make arguments to the program positional$&#10;&#10;#741: FILE: monit.c:741:&#10;+         independent. These options are handled last, here as they represent exit$&#10;&#10;#742: FILE: monit.c:742:&#10;+         points in the application and the control-file might be set with -c and$&#10;&#10;#743: FILE: monit.c:743:&#10;+         these options need to respect the new control-file location as they call$&#10;&#10;#744: FILE: monit.c:744:&#10;+         do_init */$&#10;&#10;#745: FILE: monit.c:745:&#10;+        switch (deferred_opt) {$&#10;&#10;#746: FILE: monit.c:746:&#10;+                case 't':$&#10;&#10;#747: FILE: monit.c:747:&#10;+                {$&#10;&#10;#748: FILE: monit.c:748:&#10;+                        do_init(); // Parses control file and initialize program, exit on error$&#10;&#10;#749: FILE: monit.c:749:&#10;+                        printf(&quot;Control file syntax OK\n&quot;);$&#10;&#10;#750: FILE: monit.c:750:&#10;+                        exit(0);$&#10;&#10;#751: FILE: monit.c:751:&#10;+                        break;$&#10;&#10;#752: FILE: monit.c:752:&#10;+                }$&#10;&#10;#753: FILE: monit.c:753:&#10;+                case 'r':$&#10;&#10;#754: FILE: monit.c:754:&#10;+                {$&#10;&#10;#755: FILE: monit.c:755:&#10;+                        do_init();$&#10;&#10;#756: FILE: monit.c:756:&#10;+                        assert(Run.id);$&#10;&#10;#757: FILE: monit.c:757:&#10;+                        printf(&quot;Reset Monit Id? [y/n]&amp;gt; &quot;);$&#10;&#10;#758: FILE: monit.c:758:&#10;+                        if ( getchar() == 'y') {$&#10;&#10;#759: FILE: monit.c:759:&#10;+                                File_delete(Run.files.id);$&#10;&#10;#760: FILE: monit.c:760:&#10;+                                Util_monitId(Run.files.id);$&#10;&#10;#761: FILE: monit.c:761:&#10;+                                kill_daemon(SIGHUP); // make any running Monit Daemon reload the new ID-File$&#10;&#10;#762: FILE: monit.c:762:&#10;+                        }$&#10;&#10;#763: FILE: monit.c:763:&#10;+                        exit(0);$&#10;&#10;#764: FILE: monit.c:764:&#10;+                        break;$&#10;&#10;#765: FILE: monit.c:765:&#10;+                }$&#10;&#10;#766: FILE: monit.c:766:&#10;+                case 'i':$&#10;&#10;#767: FILE: monit.c:767:&#10;+                {$&#10;&#10;#768: FILE: monit.c:768:&#10;+                        do_init();$&#10;&#10;#769: FILE: monit.c:769:&#10;+                        assert(Run.id);$&#10;&#10;#770: FILE: monit.c:770:&#10;+                        printf(&quot;Monit ID: %s\n&quot;, Run.id);$&#10;&#10;#771: FILE: monit.c:771:&#10;+                        exit(0);$&#10;&#10;#772: FILE: monit.c:772:&#10;+                        break;$&#10;&#10;#773: FILE: monit.c:773:&#10;+                }$&#10;&#10;#774: FILE: monit.c:774:&#10;+        }$&#10;&#10;#782: FILE: monit.c:782:&#10;+        printf(&quot;Usage: %s [options]+ [command]\n&quot;, prog);$&#10;&#10;#783: FILE: monit.c:783:&#10;+        printf(&quot;Options are as follows:\n&quot;);$&#10;&#10;#784: FILE: monit.c:784:&#10;+        printf(&quot; -c file       Use this control file\n&quot;);$&#10;&#10;#785: FILE: monit.c:785:&#10;+        printf(&quot; -d n          Run as a daemon once per n seconds\n&quot;);$&#10;&#10;#786: FILE: monit.c:786:&#10;+        printf(&quot; -g name       Set group name for monit commands\n&quot;);$&#10;&#10;#787: FILE: monit.c:787:&#10;+        printf(&quot; -l logfile    Print log information to this file\n&quot;);$&#10;&#10;#788: FILE: monit.c:788:&#10;+        printf(&quot; -p pidfile    Use this lock file in daemon mode\n&quot;);$&#10;&#10;#789: FILE: monit.c:789:&#10;+        printf(&quot; -s statefile  Set the file monit should write state information to\n&quot;);$&#10;&#10;#790: FILE: monit.c:790:&#10;+        printf(&quot; -I            Do not run in background (needed for run from init)\n&quot;);$&#10;&#10;#791: FILE: monit.c:791:&#10;+        printf(&quot; --id          Print Monit's unique ID\n&quot;);$&#10;&#10;#792: FILE: monit.c:792:&#10;+        printf(&quot; --resetid     Reset Monit's unique ID. Use with caution\n&quot;);$&#10;&#10;#793: FILE: monit.c:793:&#10;+        printf(&quot; -t            Run syntax check for the control file\n&quot;);$&#10;&#10;#794: FILE: monit.c:794:&#10;+        printf(&quot; -v            Verbose mode, work noisy (diagnostic output)\n&quot;);$&#10;&#10;#795: FILE: monit.c:795:&#10;+        printf(&quot; -vv           Very verbose mode, same as -v plus log stacktrace on error\n&quot;);$&#10;&#10;#796: FILE: monit.c:796:&#10;+        printf(&quot; -H [filename] Print SHA1 and MD5 hashes of the file or of stdin if the\n&quot;);$&#10;&#10;#797: FILE: monit.c:797:&#10;+        printf(&quot;               filename is omited; monit will exit afterwards\n&quot;);$&#10;&#10;#798: FILE: monit.c:798:&#10;+        printf(&quot; -V            Print version number and patchlevel\n&quot;);$&#10;&#10;#799: FILE: monit.c:799:&#10;+        printf(&quot; -h            Print this text\n&quot;);$&#10;&#10;#800: FILE: monit.c:800:&#10;+        printf(&quot;Optional commands are as follows:\n&quot;);$&#10;&#10;#801: FILE: monit.c:801:&#10;+        printf(&quot; start all           - Start all services\n&quot;);$&#10;&#10;#802: FILE: monit.c:802:&#10;+        printf(&quot; start &amp;lt;name&amp;gt;        - Only start the named service\n&quot;);$&#10;&#10;#803: FILE: monit.c:803:&#10;+        printf(&quot; stop all            - Stop all services\n&quot;);$&#10;&#10;#804: FILE: monit.c:804:&#10;+        printf(&quot; stop &amp;lt;name&amp;gt;         - Only stop the named service\n&quot;);$&#10;&#10;#805: FILE: monit.c:805:&#10;+        printf(&quot; restart all         - Stop and start all services\n&quot;);$&#10;&#10;#806: FILE: monit.c:806:&#10;+        printf(&quot; restart &amp;lt;name&amp;gt;      - Only restart the named service\n&quot;);$&#10;&#10;#807: FILE: monit.c:807:&#10;+        printf(&quot; monitor all         - Enable monitoring of all services\n&quot;);$&#10;&#10;#808: FILE: monit.c:808:&#10;+        printf(&quot; monitor &amp;lt;name&amp;gt;      - Only enable monitoring of the named service\n&quot;);$&#10;&#10;#809: FILE: monit.c:809:&#10;+        printf(&quot; unmonitor all       - Disable monitoring of all services\n&quot;);$&#10;&#10;#810: FILE: monit.c:810:&#10;+        printf(&quot; unmonitor &amp;lt;name&amp;gt;    - Only disable monitoring of the named service\n&quot;);$&#10;&#10;#811: FILE: monit.c:811:&#10;+        printf(&quot; reload              - Reinitialize monit\n&quot;);$&#10;&#10;#812: FILE: monit.c:812:&#10;+        printf(&quot; status [name]       - Print full status information for service(s)\n&quot;);$&#10;&#10;#813: FILE: monit.c:813:&#10;+        printf(&quot; summary [name]      - Print short status information for service(s)\n&quot;);$&#10;&#10;#814: FILE: monit.c:814:&#10;+        printf(&quot; quit                - Kill monit daemon process\n&quot;);$&#10;&#10;#815: FILE: monit.c:815:&#10;+        printf(&quot; validate            - Check all services and start if not running\n&quot;);$&#10;&#10;#816: FILE: monit.c:816:&#10;+        printf(&quot; procmatch &amp;lt;pattern&amp;gt; - Test process matching pattern\n&quot;);$&#10;&#10;#817: FILE: monit.c:817:&#10;+        printf(&quot;\n&quot;);$&#10;&#10;#818: FILE: monit.c:818:&#10;+        printf(&quot;(Action arguments operate on services defined in the control file)\n&quot;);$&#10;&#10;#825: FILE: monit.c:825:&#10;+        printf(&quot;This is Monit version %s\n&quot;, VERSION);$&#10;&#10;#826: FILE: monit.c:826:&#10;+        printf(&quot;Built with&quot;);$&#10;&#10;#828: FILE: monit.c:828:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#830: FILE: monit.c:830:&#10;+        printf(&quot; ssl, with&quot;);$&#10;&#10;#832: FILE: monit.c:832:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#834: FILE: monit.c:834:&#10;+        printf(&quot; pam and with&quot;);$&#10;&#10;#836: FILE: monit.c:836:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#838: FILE: monit.c:838:&#10;+        printf(&quot; large files\n&quot;);$&#10;&#10;#839: FILE: monit.c:839:&#10;+        printf(&quot;Copyright (C) 2001-2016 Tildeslash Ltd. All Rights Reserved.\n&quot;);$&#10;&#10;#847: FILE: monit.c:847:&#10;+        set_signal_block();$&#10;&#10;#848: FILE: monit.c:848:&#10;+        LogInfo(&quot;M/Monit heartbeat started\n&quot;);$&#10;&#10;#849: FILE: monit.c:849:&#10;+        LOCK(heartbeatMutex)$&#10;&#10;#850: FILE: monit.c:850:&#10;+        {$&#10;&#10;#851: FILE: monit.c:851:&#10;+                while (! (Run.flags &amp;amp; Run_Stopped) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_DoReload)) {$&#10;&#10;#852: FILE: monit.c:852:&#10;+                        handle_mmonit(NULL);$&#10;&#10;#853: FILE: monit.c:853:&#10;+                        struct timespec wait = {.tv_sec = Time_now() + Run.polltime, .tv_nsec = 0};$&#10;&#10;#854: FILE: monit.c:854:&#10;+                        Sem_timeWait(heartbeatCond, heartbeatMutex, wait);$&#10;&#10;#855: FILE: monit.c:855:&#10;+                }$&#10;&#10;#856: FILE: monit.c:856:&#10;+        }$&#10;&#10;#857: FILE: monit.c:857:&#10;+        END_LOCK;$&#10;&#10;#859: FILE: monit.c:859:&#10;+        Ssl_threadCleanup();$&#10;&#10;#861: FILE: monit.c:861:&#10;+        LogInfo(&quot;M/Monit heartbeat stopped\n&quot;);$&#10;&#10;#862: FILE: monit.c:862:&#10;+        return NULL;$&#10;&#10;#870: FILE: monit.c:870:&#10;+        Run.flags |= Run_DoReload;$&#10;&#10;#878: FILE: monit.c:878:&#10;+        Run.flags |= Run_Stopped;$&#10;&#10;#886: FILE: monit.c:886:&#10;+        Run.flags |= Run_DoWakeup;$&#10;&#10;#893: FILE: monit.c:893:&#10;+        while (waitpid(-1, NULL, WNOHANG) &amp;gt; 0) ;$&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="TRAILING_STATEMENTS">
  <failure type="TRAILING_STATEMENTS">TRAILING_STATEMENTS</failure>
  <system-err>
trailing statements should be on next line&#10;#893: FILE: monit.c:893:&#10;+        while (waitpid(-1, NULL, WNOHANG) &amp;gt; 0) ;&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="BLOCK_COMMENT_STYLE">
  <failure type="BLOCK_COMMENT_STYLE">BLOCK_COMMENT_STYLE</failure>
  <system-err>
Block comments use * on subsequent lines&#10;#325: FILE: monit.c:325:&#10;+        /* Wait non-blocking for any children that has exited. Since we&#10;+         reinitialize any information about children we have setup to wait&#10;&#10;#329: FILE: monit.c:329:&#10;+         globale process table which a sigchld handler can check */&#10;&#10;#741: FILE: monit.c:741:&#10;+        /* Handle deferred options to make arguments to the program positional&#10;+         independent. These options are handled last, here as they represent exit&#10;&#10;#744: FILE: monit.c:744:&#10;+         do_init */&#10;&#10;#891: FILE: monit.c:891:&#10;+/* A simple non-blocking reaper to ensure that we wait-for and reap all/any stray child processes&#10;+ we may have created and not waited on, so we do not create any zombie processes at exit */&#10;&#10;#891: FILE: monit.c:891:&#10;+ we may have created and not waited on, so we do not create any zombie processes at exit */&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="LINE_SPACING">
  <failure type="LINE_SPACING">LINE_SPACING</failure>
  <system-err>
Missing a blank line after declarations&#10;#415: FILE: monit.c:415:&#10;+                        List_T services = List_new();&#10;+                        if (Run.mygroup) {&#10;&#10;#420: FILE: monit.c:420:&#10;+                                                        Service_T s = m-&amp;gt;e;&#10;+                                                        List_append(services, s-&amp;gt;name);&#10;&#10;#597: FILE: monit.c:597:&#10;+        int deferred_opt = 0;&#10;+        opterr = 0;&#10;&#10;#627: FILE: monit.c:627:&#10;+                                        char *f = optarg;&#10;+                                        if (f[0] != SEPARATOR_CHAR)&#10;&#10;#854: FILE: monit.c:854:&#10;+                        struct timespec wait = {.tv_sec = Time_now() + Run.polltime, .tv_nsec = 0};&#10;+                        Sem_timeWait(heartbeatCond, heartbeatMutex, wait);&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="SWITCH_CASE_INDENT_LEVEL">
  <failure type="SWITCH_CASE_INDENT_LEVEL">SWITCH_CASE_INDENT_LEVEL</failure>
  <system-err>
switch and case should be at the same indent&#10;#623: FILE: monit.c:623:&#10;+                        switch (opt) {&#10;+                                case 'c':&#10;[...]&#10;+                                case 'd':&#10;[...]&#10;+                                case 'g':&#10;[...]&#10;+                                case 'l':&#10;[...]&#10;+                                case 'p':&#10;[...]&#10;+                                case 's':&#10;[...]&#10;+                                case 'I':&#10;[...]&#10;+                                case 'i':&#10;[...]&#10;+                                case 'r':&#10;[...]&#10;+                                case 't':&#10;[...]&#10;+                                case 'v':&#10;[...]&#10;+                                case 'H':&#10;[...]&#10;+                                case 'V':&#10;[...]&#10;+                                case 'h':&#10;[...]&#10;+                                case '?':&#10;&#10;#720: FILE: monit.c:720:&#10;+                                        switch (optopt) {&#10;+                                                case 'c':&#10;+                                                case 'd':&#10;+                                                case 'g':&#10;+                                                case 'l':&#10;+                                                case 'p':&#10;+                                                case 's':&#10;[...]&#10;+                                                default:&#10;&#10;#745: FILE: monit.c:745:&#10;+        switch (deferred_opt) {&#10;+                case 't':&#10;[...]&#10;+                case 'r':&#10;[...]&#10;+                case 'i':&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="SPACING">
  <failure type="SPACING">SPACING</failure>
  <system-err>
space prohibited after that '!' (ctx:BxW)&#10;#265: FILE: monit.c:265:&#10;+        if (! Run.files.control)&#10;             ^&#10;&#10;#278: FILE: monit.c:278:&#10;+        if (! parse(Run.files.control))&#10;             ^&#10;&#10;#284: FILE: monit.c:284:&#10;+        if (! log_init())&#10;             ^&#10;&#10;#290: FILE: monit.c:290:&#10;+        if (! servicelist) {&#10;             ^&#10;&#10;#351: FILE: monit.c:351:&#10;+        if (! parse(Run.files.control)) {&#10;             ^&#10;&#10;#360: FILE: monit.c:360:&#10;+        if (! log_init())&#10;             ^&#10;&#10;#364: FILE: monit.c:364:&#10;+        if (! servicelist) {&#10;             ^&#10;&#10;#372: FILE: monit.c:372:&#10;+        if (! file_createPidFile(Run.files.pid)) {&#10;             ^&#10;&#10;#378: FILE: monit.c:378:&#10;+        if (! State_open())&#10;             ^&#10;&#10;#405: FILE: monit.c:405:&#10;+        if (! action) {&#10;             ^&#10;&#10;#448: FILE: monit.c:448:&#10;+                if (! status(LEVEL_NAME_FULL, Run.mygroup, service))&#10;                     ^&#10;&#10;#451: FILE: monit.c:451:&#10;+                if (! status(LEVEL_NAME_SUMMARY, Run.mygroup, service))&#10;                     ^&#10;&#10;#454: FILE: monit.c:454:&#10;+                if (! service) {&#10;                     ^&#10;&#10;#480: FILE: monit.c:480:&#10;+        if ((Run.flags &amp;amp; Run_Daemon) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Once)) {&#10;                                         ^&#10;&#10;#526: FILE: monit.c:526:&#10;+                if (! (Run.flags &amp;amp; Run_Foreground))&#10;                     ^&#10;&#10;#528: FILE: monit.c:528:&#10;+                else if (! Run.debug)&#10;                          ^&#10;&#10;#531: FILE: monit.c:531:&#10;+                if (! file_createPidFile(Run.files.pid)) {&#10;                     ^&#10;&#10;#536: FILE: monit.c:536:&#10;+                if (! State_open())&#10;                     ^&#10;&#10;#571: FILE: monit.c:571:&#10;+                        if (! (Run.flags &amp;amp; Run_ActionPending) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Stopped))&#10;                             ^&#10;&#10;#571: FILE: monit.c:571:&#10;+                        if (! (Run.flags &amp;amp; Run_ActionPending) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Stopped))&#10;                                                                  ^&#10;&#10;#628: FILE: monit.c:628:&#10;+                                                f = File_getRealPath(optarg, (char[PATH_MAX]){});&#10;&#10;#629: FILE: monit.c:629:&#10;+                                        if (! f)&#10;                                             ^&#10;&#10;#631: FILE: monit.c:631:&#10;+                                                      Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));&#10;&#10;#632: FILE: monit.c:632:&#10;+                                        if (! File_isFile(f))&#10;                                             ^&#10;&#10;#634: FILE: monit.c:634:&#10;+                                        if (! File_isReadable(f))&#10;                                             ^&#10;&#10;#758: FILE: monit.c:758:&#10;+                        if ( getchar() == 'y') {&#10;&#10;#851: FILE: monit.c:851:&#10;+                while (! (Run.flags &amp;amp; Run_Stopped) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_DoReload)) {&#10;                        ^&#10;&#10;#851: FILE: monit.c:851:&#10;+                while (! (Run.flags &amp;amp; Run_Stopped) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_DoReload)) {&#10;                                                       ^&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="C99_COMMENTS">
  <failure type="C99_COMMENTS">C99_COMMENTS</failure>
  <system-err>
do not use C99 // comments&#10;#80: FILE: monit.c:80:&#10;+// libmonit&#10;&#10;#156: FILE: monit.c:156:&#10;+        Bootstrap(); // Bootstrap libmonit&#10;&#10;#157: FILE: monit.c:157:&#10;+        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit&#10;&#10;#748: FILE: monit.c:748:&#10;+                        do_init(); // Parses control file and initialize program, exit on error&#10;&#10;#761: FILE: monit.c:761:&#10;+                                kill_daemon(SIGHUP); // make any running Monit Daemon reload the new ID-File&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="VOLATILE">
  <failure type="VOLATILE">VOLATILE</failure>
  <system-err>
Use of volatile is usually wrong: see Documentation/volatile-considered-harmful.txt&#10;#132: FILE: monit.c:132:&#10;+static volatile boolean_t heartbeatRunning = false;&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="UNSPECIFIED_INT">
  <failure type="UNSPECIFIED_INT">UNSPECIFIED_INT</failure>
  <system-err>
Prefer 'unsigned int' to bare use of 'unsigned'&#10;#247: FILE: monit.c:247:&#10;+        srandom((unsigned)(Time_now() + getpid()));&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="LONG_LINE_COMMENT">
  <failure type="LONG_LINE_COMMENT">LONG_LINE_COMMENT</failure>
  <system-err>
line over 80 characters&#10;#157: FILE: monit.c:157:&#10;+        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit&#10;&#10;#344: FILE: monit.c:344:&#10;+        /* Save the current state (no changes are possible now since the http thread is stopped) */&#10;&#10;#546: FILE: monit.c:546:&#10;+                        /* sleep can be interrupted by signal =&amp;gt; make sure we paused long enough */&#10;&#10;#570: FILE: monit.c:570:&#10;+                        /* In the case that there is no pending action then sleep */&#10;&#10;#741: FILE: monit.c:741:&#10;+         independent. These options are handled last, here as they represent exit&#10;&#10;#743: FILE: monit.c:743:&#10;+         these options need to respect the new control-file location as they call&#10;&#10;#748: FILE: monit.c:748:&#10;+                        do_init(); // Parses control file and initialize program, exit on error&#10;&#10;#761: FILE: monit.c:761:&#10;+                                kill_daemon(SIGHUP); // make any running Monit Daemon reload the new ID-File&#10;&#10;#890: FILE: monit.c:890:&#10;+/* A simple non-blocking reaper to ensure that we wait-for and reap all/any stray child processes&#10;&#10;#891: FILE: monit.c:891:&#10;+ we may have created and not waited on, so we do not create any zombie processes at exit */&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="SSCANF_TO_KSTRTO">
  <failure type="SSCANF_TO_KSTRTO">SSCANF_TO_KSTRTO</failure>
  <system-err>
'Prefer kstrto&amp;lt;type&amp;gt; to single variable sscanf&#10;#642: FILE: monit.c:642:&#10;+                                        sscanf(optarg, "%d", &amp;amp;Run.polltime);&#10;&#10;'

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="LONG_LINE_STRING">
  <failure type="LONG_LINE_STRING">LONG_LINE_STRING</failure>
  <system-err>
line over 80 characters&#10;#455: FILE: monit.c:455:&#10;+                        printf(&quot;Invalid syntax - usage: procmatch \&quot;&amp;lt;pattern&amp;gt;\&quot;\n&quot;);&#10;&#10;#630: FILE: monit.c:630:&#10;+                                                THROW(AssertException, &quot;The control file '%s' does not exist at %s&quot;,&#10;&#10;#789: FILE: monit.c:789:&#10;+        printf(&quot; -s statefile  Set the file monit should write state information to\n&quot;);&#10;&#10;#790: FILE: monit.c:790:&#10;+        printf(&quot; -I            Do not run in background (needed for run from init)\n&quot;);&#10;&#10;#795: FILE: monit.c:795:&#10;+        printf(&quot; -vv           Very verbose mode, same as -v plus log stacktrace on error\n&quot;);&#10;&#10;#796: FILE: monit.c:796:&#10;+        printf(&quot; -H [filename] Print SHA1 and MD5 hashes of the file or of stdin if the\n&quot;);&#10;&#10;#797: FILE: monit.c:797:&#10;+        printf(&quot;               filename is omited; monit will exit afterwards\n&quot;);&#10;&#10;#808: FILE: monit.c:808:&#10;+        printf(&quot; monitor &amp;lt;name&amp;gt;      - Only enable monitoring of the named service\n&quot;);&#10;&#10;#810: FILE: monit.c:810:&#10;+        printf(&quot; unmonitor &amp;lt;name&amp;gt;    - Only disable monitoring of the named service\n&quot;);&#10;&#10;#812: FILE: monit.c:812:&#10;+        printf(&quot; status [name]       - Print full status information for service(s)\n&quot;);&#10;&#10;#813: FILE: monit.c:813:&#10;+        printf(&quot; summary [name]      - Print short status information for service(s)\n&quot;);&#10;&#10;#815: FILE: monit.c:815:&#10;+        printf(&quot; validate            - Check all services and start if not running\n&quot;);&#10;&#10;#818: FILE: monit.c:818:&#10;+        printf(&quot;(Action arguments operate on services defined in the control file)\n&quot;);&#10;&#10;#839: FILE: monit.c:839:&#10;+        printf(&quot;Copyright (C) 2001-2016 Tildeslash Ltd. All Rights Reserved.\n&quot;);&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="INITIALISED_STATIC">
  <failure type="INITIALISED_STATIC">INITIALISED_STATIC</failure>
  <system-err>
do not initialise statics to false&#10;#132: FILE: monit.c:132:&#10;+static volatile boolean_t heartbeatRunning = false;&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="LEADING_SPACE">
  <failure type="LEADING_SPACE">LEADING_SPACE</failure>
  <system-err>
please, no spaces at the start of a line&#10;#156: FILE: monit.c:156:&#10;+        Bootstrap(); // Bootstrap libmonit$&#10;&#10;#157: FILE: monit.c:157:&#10;+        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit$&#10;&#10;#158: FILE: monit.c:158:&#10;+        Bootstrap_setErrorHandler(vLogError);$&#10;&#10;#159: FILE: monit.c:159:&#10;+        setlocale(LC_ALL, &quot;C&quot;);$&#10;&#10;#160: FILE: monit.c:160:&#10;+        prog = File_basename(argv[0]);$&#10;&#10;#162: FILE: monit.c:162:&#10;+        Ssl_start();$&#10;&#10;#164: FILE: monit.c:164:&#10;+        init_env();$&#10;&#10;#165: FILE: monit.c:165:&#10;+        handle_options(argc, argv);$&#10;&#10;#166: FILE: monit.c:166:&#10;+        do_init();$&#10;&#10;#167: FILE: monit.c:167:&#10;+        do_action(argv);$&#10;&#10;#168: FILE: monit.c:168:&#10;+        do_exit();$&#10;&#10;#169: FILE: monit.c:169:&#10;+        return 0;$&#10;&#10;#178: FILE: monit.c:178:&#10;+        pid_t pid;$&#10;&#10;#180: FILE: monit.c:180:&#10;+        if ((pid = exist_daemon()) &amp;gt; 0) {$&#10;&#10;#181: FILE: monit.c:181:&#10;+                kill(pid, SIGUSR1);$&#10;&#10;#182: FILE: monit.c:182:&#10;+                LogInfo(&quot;Monit daemon with PID %d awakened\n&quot;, pid);$&#10;&#10;#184: FILE: monit.c:184:&#10;+                return true;$&#10;&#10;#185: FILE: monit.c:185:&#10;+        }$&#10;&#10;#187: FILE: monit.c:187:&#10;+        return false;$&#10;&#10;#195: FILE: monit.c:195:&#10;+        if (State_open()) {$&#10;&#10;#196: FILE: monit.c:196:&#10;+                State_restore();$&#10;&#10;#197: FILE: monit.c:197:&#10;+                validate();$&#10;&#10;#198: FILE: monit.c:198:&#10;+                State_save();$&#10;&#10;#199: FILE: monit.c:199:&#10;+                State_close();$&#10;&#10;#200: FILE: monit.c:200:&#10;+        }$&#10;&#10;#215: FILE: monit.c:215:&#10;+        signal(SIGTERM, do_destroy);$&#10;&#10;#222: FILE: monit.c:222:&#10;+        signal(SIGUSR1, do_wakeup);$&#10;&#10;#230: FILE: monit.c:230:&#10;+        signal(SIGINT, do_destroy);$&#10;&#10;#237: FILE: monit.c:237:&#10;+        signal(SIGHUP, do_reload);$&#10;&#10;#242: FILE: monit.c:242:&#10;+        signal(SIGPIPE, SIG_IGN);$&#10;&#10;#247: FILE: monit.c:247:&#10;+        srandom((unsigned)(Time_now() + getpid()));$&#10;&#10;#254: FILE: monit.c:254:&#10;+        Mutex_init(Run.mutex);$&#10;&#10;#259: FILE: monit.c:259:&#10;+        Mutex_init(heartbeatMutex);$&#10;&#10;#260: FILE: monit.c:260:&#10;+        Sem_init(heartbeatCond);$&#10;&#10;#265: FILE: monit.c:265:&#10;+        if (! Run.files.control)$&#10;&#10;#266: FILE: monit.c:266:&#10;+                Run.files.control = file_findControlFile();$&#10;&#10;#271: FILE: monit.c:271:&#10;+        if (init_process_info())$&#10;&#10;#272: FILE: monit.c:272:&#10;+                Run.flags |= Run_ProcessEngineEnabled;$&#10;&#10;#278: FILE: monit.c:278:&#10;+        if (! parse(Run.files.control))$&#10;&#10;#279: FILE: monit.c:279:&#10;+                exit(1);$&#10;&#10;#284: FILE: monit.c:284:&#10;+        if (! log_init())$&#10;&#10;#285: FILE: monit.c:285:&#10;+                exit(1);$&#10;&#10;#290: FILE: monit.c:290:&#10;+        if (! servicelist) {$&#10;&#10;#291: FILE: monit.c:291:&#10;+                LogError(&quot;No services has been specified\n&quot;);$&#10;&#10;#292: FILE: monit.c:292:&#10;+                exit(0);$&#10;&#10;#293: FILE: monit.c:293:&#10;+        }$&#10;&#10;#298: FILE: monit.c:298:&#10;+        file_init();$&#10;&#10;#303: FILE: monit.c:303:&#10;+        if (Run.debug) {$&#10;&#10;#304: FILE: monit.c:304:&#10;+                Util_printRunList();$&#10;&#10;#305: FILE: monit.c:305:&#10;+                Util_printServiceList();$&#10;&#10;#306: FILE: monit.c:306:&#10;+        }$&#10;&#10;#311: FILE: monit.c:311:&#10;+        atexit(waitforchildren);$&#10;&#10;#320: FILE: monit.c:320:&#10;+        LogInfo(&quot;Awakened by the SIGHUP signal\n&quot;$&#10;&#10;#321: FILE: monit.c:321:&#10;+                &quot;Reinitializing Monit - Control file '%s'\n&quot;,$&#10;&#10;#322: FILE: monit.c:322:&#10;+                Run.files.control);$&#10;&#10;#330: FILE: monit.c:330:&#10;+        waitforchildren();$&#10;&#10;#332: FILE: monit.c:332:&#10;+        if (Run.mmonits &amp;amp;&amp;amp; heartbeatRunning) {$&#10;&#10;#333: FILE: monit.c:333:&#10;+                Sem_signal(heartbeatCond);$&#10;&#10;#334: FILE: monit.c:334:&#10;+                Thread_join(heartbeatThread);$&#10;&#10;#335: FILE: monit.c:335:&#10;+                heartbeatRunning = false;$&#10;&#10;#336: FILE: monit.c:336:&#10;+        }$&#10;&#10;#338: FILE: monit.c:338:&#10;+        Run.flags &amp;amp;= ~Run_DoReload;$&#10;&#10;#341: FILE: monit.c:341:&#10;+        if (Run.httpd.flags &amp;amp; Httpd_Net || Run.httpd.flags &amp;amp; Httpd_Unix)$&#10;&#10;#342: FILE: monit.c:342:&#10;+                monit_http(Httpd_Stop);$&#10;&#10;#345: FILE: monit.c:345:&#10;+        State_save();$&#10;&#10;#346: FILE: monit.c:346:&#10;+        State_close();$&#10;&#10;#349: FILE: monit.c:349:&#10;+        gc();$&#10;&#10;#351: FILE: monit.c:351:&#10;+        if (! parse(Run.files.control)) {$&#10;&#10;#352: FILE: monit.c:352:&#10;+                LogError(&quot;%s stopped -- configuration file parsing error\n&quot;, prog);$&#10;&#10;#353: FILE: monit.c:353:&#10;+                exit(1);$&#10;&#10;#354: FILE: monit.c:354:&#10;+        }$&#10;&#10;#357: FILE: monit.c:357:&#10;+        log_close();$&#10;&#10;#360: FILE: monit.c:360:&#10;+        if (! log_init())$&#10;&#10;#361: FILE: monit.c:361:&#10;+                exit(1);$&#10;&#10;#364: FILE: monit.c:364:&#10;+        if (! servicelist) {$&#10;&#10;#365: FILE: monit.c:365:&#10;+                LogError(&quot;No services has been specified\n&quot;);$&#10;&#10;#366: FILE: monit.c:366:&#10;+                exit(0);$&#10;&#10;#367: FILE: monit.c:367:&#10;+        }$&#10;&#10;#370: FILE: monit.c:370:&#10;+        file_init();$&#10;&#10;#372: FILE: monit.c:372:&#10;+        if (! file_createPidFile(Run.files.pid)) {$&#10;&#10;#373: FILE: monit.c:373:&#10;+                LogError(&quot;%s stopped -- cannot create a pid file\n&quot;, prog);$&#10;&#10;#374: FILE: monit.c:374:&#10;+                exit(1);$&#10;&#10;#375: FILE: monit.c:375:&#10;+        }$&#10;&#10;#378: FILE: monit.c:378:&#10;+        if (! State_open())$&#10;&#10;#379: FILE: monit.c:379:&#10;+                exit(1);$&#10;&#10;#380: FILE: monit.c:380:&#10;+        State_restore();$&#10;&#10;#383: FILE: monit.c:383:&#10;+        if (can_http())$&#10;&#10;#384: FILE: monit.c:384:&#10;+                monit_http(Httpd_Start);$&#10;&#10;#387: FILE: monit.c:387:&#10;+        Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit reloaded&quot;);$&#10;&#10;#389: FILE: monit.c:389:&#10;+        if (Run.mmonits) {$&#10;&#10;#390: FILE: monit.c:390:&#10;+                Thread_create(heartbeatThread, heartbeat, NULL);$&#10;&#10;#391: FILE: monit.c:391:&#10;+                heartbeatRunning = true;$&#10;&#10;#392: FILE: monit.c:392:&#10;+        }$&#10;&#10;#400: FILE: monit.c:400:&#10;+        char *action = args[optind];$&#10;&#10;#401: FILE: monit.c:401:&#10;+        char *service = args[++optind];$&#10;&#10;#403: FILE: monit.c:403:&#10;+        Run.flags |= Run_Once;$&#10;&#10;#405: FILE: monit.c:405:&#10;+        if (! action) {$&#10;&#10;#406: FILE: monit.c:406:&#10;+                do_default();$&#10;&#10;#407: FILE: monit.c:407:&#10;+        } else if (IS(action, &quot;start&quot;)     ||$&#10;&#10;#408: FILE: monit.c:408:&#10;+                   IS(action, &quot;stop&quot;)      ||$&#10;&#10;#409: FILE: monit.c:409:&#10;+                   IS(action, &quot;monitor&quot;)   ||$&#10;&#10;#410: FILE: monit.c:410:&#10;+                   IS(action, &quot;unmonitor&quot;) ||$&#10;&#10;#411: FILE: monit.c:411:&#10;+                   IS(action, &quot;restart&quot;)) {$&#10;&#10;#412: FILE: monit.c:412:&#10;+                if (Run.mygroup || service) {$&#10;&#10;#413: FILE: monit.c:413:&#10;+                        int errors = 0;$&#10;&#10;#414: FILE: monit.c:414:&#10;+                        List_T services = List_new();$&#10;&#10;#415: FILE: monit.c:415:&#10;+                        if (Run.mygroup) {$&#10;&#10;#416: FILE: monit.c:416:&#10;+                                for (ServiceGroup_T sg = servicegrouplist; sg; sg = sg-&amp;gt;next) {$&#10;&#10;#417: FILE: monit.c:417:&#10;+                                        if (IS(Run.mygroup, sg-&amp;gt;name)) {$&#10;&#10;#418: FILE: monit.c:418:&#10;+                                                for (list_t m = sg-&amp;gt;members-&amp;gt;head; m; m = m-&amp;gt;next) {$&#10;&#10;#419: FILE: monit.c:419:&#10;+                                                        Service_T s = m-&amp;gt;e;$&#10;&#10;#420: FILE: monit.c:420:&#10;+                                                        List_append(services, s-&amp;gt;name);$&#10;&#10;#421: FILE: monit.c:421:&#10;+                                                }$&#10;&#10;#422: FILE: monit.c:422:&#10;+                                                break;$&#10;&#10;#423: FILE: monit.c:423:&#10;+                                        }$&#10;&#10;#424: FILE: monit.c:424:&#10;+                                }$&#10;&#10;#425: FILE: monit.c:425:&#10;+                                if (List_length(services) == 0) {$&#10;&#10;#426: FILE: monit.c:426:&#10;+                                        List_free(&amp;amp;services);$&#10;&#10;#427: FILE: monit.c:427:&#10;+                                        LogError(&quot;Group '%s' not found\n&quot;, Run.mygroup);$&#10;&#10;#428: FILE: monit.c:428:&#10;+                                        exit(1);$&#10;&#10;#429: FILE: monit.c:429:&#10;+                                }$&#10;&#10;#430: FILE: monit.c:430:&#10;+                        } else if (IS(service, &quot;all&quot;)) {$&#10;&#10;#431: FILE: monit.c:431:&#10;+                                for (Service_T s = servicelist; s; s = s-&amp;gt;next)$&#10;&#10;#432: FILE: monit.c:432:&#10;+                                        List_append(services, s-&amp;gt;name);$&#10;&#10;#433: FILE: monit.c:433:&#10;+                        } else {$&#10;&#10;#434: FILE: monit.c:434:&#10;+                                List_append(services, service);$&#10;&#10;#435: FILE: monit.c:435:&#10;+                        }$&#10;&#10;#436: FILE: monit.c:436:&#10;+                        errors = exist_daemon() ? control_service_daemon(services, action) : control_service_string(services, action);$&#10;&#10;#437: FILE: monit.c:437:&#10;+                        List_free(&amp;amp;services);$&#10;&#10;#438: FILE: monit.c:438:&#10;+                        if (errors)$&#10;&#10;#439: FILE: monit.c:439:&#10;+                                exit(1);$&#10;&#10;#440: FILE: monit.c:440:&#10;+                } else {$&#10;&#10;#441: FILE: monit.c:441:&#10;+                        LogError(&quot;Please specify a service name or 'all' after %s\n&quot;, action);$&#10;&#10;#442: FILE: monit.c:442:&#10;+                        exit(1);$&#10;&#10;#443: FILE: monit.c:443:&#10;+                }$&#10;&#10;#444: FILE: monit.c:444:&#10;+        } else if (IS(action, &quot;reload&quot;)) {$&#10;&#10;#445: FILE: monit.c:445:&#10;+                LogInfo(&quot;Reinitializing %s daemon\n&quot;, prog);$&#10;&#10;#446: FILE: monit.c:446:&#10;+                kill_daemon(SIGHUP);$&#10;&#10;#447: FILE: monit.c:447:&#10;+        } else if (IS(action, &quot;status&quot;)) {$&#10;&#10;#448: FILE: monit.c:448:&#10;+                if (! status(LEVEL_NAME_FULL, Run.mygroup, service))$&#10;&#10;#449: FILE: monit.c:449:&#10;+                        exit(1);$&#10;&#10;#450: FILE: monit.c:450:&#10;+        } else if (IS(action, &quot;summary&quot;)) {$&#10;&#10;#451: FILE: monit.c:451:&#10;+                if (! status(LEVEL_NAME_SUMMARY, Run.mygroup, service))$&#10;&#10;#452: FILE: monit.c:452:&#10;+                        exit(1);$&#10;&#10;#453: FILE: monit.c:453:&#10;+        } else if (IS(action, &quot;procmatch&quot;)) {$&#10;&#10;#454: FILE: monit.c:454:&#10;+                if (! service) {$&#10;&#10;#455: FILE: monit.c:455:&#10;+                        printf(&quot;Invalid syntax - usage: procmatch \&quot;&amp;lt;pattern&amp;gt;\&quot;\n&quot;);$&#10;&#10;#456: FILE: monit.c:456:&#10;+                        exit(1);$&#10;&#10;#457: FILE: monit.c:457:&#10;+                }$&#10;&#10;#458: FILE: monit.c:458:&#10;+                process_testmatch(service);$&#10;&#10;#459: FILE: monit.c:459:&#10;+        } else if (IS(action, &quot;quit&quot;)) {$&#10;&#10;#460: FILE: monit.c:460:&#10;+                kill_daemon(SIGTERM);$&#10;&#10;#461: FILE: monit.c:461:&#10;+        } else if (IS(action, &quot;validate&quot;)) {$&#10;&#10;#462: FILE: monit.c:462:&#10;+                if (do_wakeupcall())$&#10;&#10;#463: FILE: monit.c:463:&#10;+                        status(LEVEL_NAME_FULL, Run.mygroup, service);$&#10;&#10;#464: FILE: monit.c:464:&#10;+                else$&#10;&#10;#465: FILE: monit.c:465:&#10;+                        _validateOnce();$&#10;&#10;#466: FILE: monit.c:466:&#10;+                exit(1);$&#10;&#10;#467: FILE: monit.c:467:&#10;+        } else {$&#10;&#10;#468: FILE: monit.c:468:&#10;+                LogError(&quot;Invalid argument -- %s  (-h will show valid arguments)\n&quot;, action);$&#10;&#10;#469: FILE: monit.c:469:&#10;+                exit(1);$&#10;&#10;#470: FILE: monit.c:470:&#10;+        }$&#10;&#10;#478: FILE: monit.c:478:&#10;+        set_signal_block();$&#10;&#10;#479: FILE: monit.c:479:&#10;+        Run.flags |= Run_Stopped;$&#10;&#10;#480: FILE: monit.c:480:&#10;+        if ((Run.flags &amp;amp; Run_Daemon) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Once)) {$&#10;&#10;#481: FILE: monit.c:481:&#10;+                if (can_http())$&#10;&#10;#482: FILE: monit.c:482:&#10;+                        monit_http(Httpd_Stop);$&#10;&#10;#484: FILE: monit.c:484:&#10;+                if (Run.mmonits &amp;amp;&amp;amp; heartbeatRunning) {$&#10;&#10;#485: FILE: monit.c:485:&#10;+                        Sem_signal(heartbeatCond);$&#10;&#10;#486: FILE: monit.c:486:&#10;+                        Thread_join(heartbeatThread);$&#10;&#10;#487: FILE: monit.c:487:&#10;+                        heartbeatRunning = false;$&#10;&#10;#488: FILE: monit.c:488:&#10;+                }$&#10;&#10;#490: FILE: monit.c:490:&#10;+                LogInfo(&quot;Monit daemon with pid [%d] stopped\n&quot;, (int)getpid());$&#10;&#10;#493: FILE: monit.c:493:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_STOP, &quot;Monit %s stopped&quot;, VERSION);$&#10;&#10;#494: FILE: monit.c:494:&#10;+        }$&#10;&#10;#495: FILE: monit.c:495:&#10;+        gc();$&#10;&#10;#497: FILE: monit.c:497:&#10;+        Ssl_stop();$&#10;&#10;#499: FILE: monit.c:499:&#10;+        exit(0);$&#10;&#10;#509: FILE: monit.c:509:&#10;+        if (Run.flags &amp;amp; Run_Daemon) {$&#10;&#10;#510: FILE: monit.c:510:&#10;+                if (do_wakeupcall())$&#10;&#10;#511: FILE: monit.c:511:&#10;+                        exit(0);$&#10;&#10;#513: FILE: monit.c:513:&#10;+                Run.flags &amp;amp;= ~Run_Once;$&#10;&#10;#514: FILE: monit.c:514:&#10;+                if (can_http()) {$&#10;&#10;#515: FILE: monit.c:515:&#10;+                        if (Run.httpd.flags &amp;amp; Httpd_Net)$&#10;&#10;#516: FILE: monit.c:516:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at [%s]:%d\n&quot;, VERSION, Run.httpd.socket.net.address ? Run.httpd.socket.net.address : &quot;*&quot;, Run.httpd.socket.net.port);$&#10;&#10;#517: FILE: monit.c:517:&#10;+                        else if (Run.httpd.flags &amp;amp; Httpd_Unix)$&#10;&#10;#518: FILE: monit.c:518:&#10;+                                LogInfo(&quot;Starting Monit %s daemon with http interface at %s\n&quot;, VERSION, Run.httpd.socket.unix.path);$&#10;&#10;#519: FILE: monit.c:519:&#10;+                } else {$&#10;&#10;#520: FILE: monit.c:520:&#10;+                        LogInfo(&quot;Starting Monit %s daemon\n&quot;, VERSION);$&#10;&#10;#521: FILE: monit.c:521:&#10;+                }$&#10;&#10;#523: FILE: monit.c:523:&#10;+                if (Run.startdelay)$&#10;&#10;#524: FILE: monit.c:524:&#10;+                        LogInfo(&quot;Monit start delay set -- pause for %ds\n&quot;, Run.startdelay);$&#10;&#10;#526: FILE: monit.c:526:&#10;+                if (! (Run.flags &amp;amp; Run_Foreground))$&#10;&#10;#527: FILE: monit.c:527:&#10;+                        daemonize();$&#10;&#10;#528: FILE: monit.c:528:&#10;+                else if (! Run.debug)$&#10;&#10;#529: FILE: monit.c:529:&#10;+                        Util_redirectStdFds();$&#10;&#10;#531: FILE: monit.c:531:&#10;+                if (! file_createPidFile(Run.files.pid)) {$&#10;&#10;#532: FILE: monit.c:532:&#10;+                        LogError(&quot;Monit daemon died\n&quot;);$&#10;&#10;#533: FILE: monit.c:533:&#10;+                        exit(1);$&#10;&#10;#534: FILE: monit.c:534:&#10;+                }$&#10;&#10;#536: FILE: monit.c:536:&#10;+                if (! State_open())$&#10;&#10;#537: FILE: monit.c:537:&#10;+                        exit(1);$&#10;&#10;#538: FILE: monit.c:538:&#10;+                State_restore();$&#10;&#10;#540: FILE: monit.c:540:&#10;+                atexit(file_finalize);$&#10;&#10;#542: FILE: monit.c:542:&#10;+                if (Run.startdelay) {$&#10;&#10;#543: FILE: monit.c:543:&#10;+                        time_t now = Time_now();$&#10;&#10;#544: FILE: monit.c:544:&#10;+                        time_t delay = now + Run.startdelay;$&#10;&#10;#547: FILE: monit.c:547:&#10;+                        while (now &amp;lt; delay) {$&#10;&#10;#548: FILE: monit.c:548:&#10;+                                sleep((unsigned int)(delay - now));$&#10;&#10;#549: FILE: monit.c:549:&#10;+                                if (Run.flags &amp;amp; Run_Stopped)$&#10;&#10;#550: FILE: monit.c:550:&#10;+                                        do_exit();$&#10;&#10;#551: FILE: monit.c:551:&#10;+                                now = Time_now();$&#10;&#10;#552: FILE: monit.c:552:&#10;+                        }$&#10;&#10;#553: FILE: monit.c:553:&#10;+                }$&#10;&#10;#555: FILE: monit.c:555:&#10;+                if (can_http())$&#10;&#10;#556: FILE: monit.c:556:&#10;+                        monit_http(Httpd_Start);$&#10;&#10;#559: FILE: monit.c:559:&#10;+                Event_post(Run.system, Event_Instance, State_Changed, Run.system-&amp;gt;action_MONIT_START, &quot;Monit %s started&quot;, VERSION);$&#10;&#10;#561: FILE: monit.c:561:&#10;+                if (Run.mmonits) {$&#10;&#10;#562: FILE: monit.c:562:&#10;+                        Thread_create(heartbeatThread, heartbeat, NULL);$&#10;&#10;#563: FILE: monit.c:563:&#10;+                        heartbeatRunning = true;$&#10;&#10;#564: FILE: monit.c:564:&#10;+                }$&#10;&#10;#566: FILE: monit.c:566:&#10;+                while (true) {$&#10;&#10;#567: FILE: monit.c:567:&#10;+                        validate();$&#10;&#10;#568: FILE: monit.c:568:&#10;+                        State_save();$&#10;&#10;#571: FILE: monit.c:571:&#10;+                        if (! (Run.flags &amp;amp; Run_ActionPending) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_Stopped))$&#10;&#10;#572: FILE: monit.c:572:&#10;+                                sleep(Run.polltime);$&#10;&#10;#574: FILE: monit.c:574:&#10;+                        if (Run.flags &amp;amp; Run_DoWakeup) {$&#10;&#10;#575: FILE: monit.c:575:&#10;+                                Run.flags &amp;amp;= ~Run_DoWakeup;$&#10;&#10;#576: FILE: monit.c:576:&#10;+                                LogInfo(&quot;Awakened by User defined signal 1\n&quot;);$&#10;&#10;#577: FILE: monit.c:577:&#10;+                        }$&#10;&#10;#579: FILE: monit.c:579:&#10;+                        if (Run.flags &amp;amp; Run_Stopped)$&#10;&#10;#580: FILE: monit.c:580:&#10;+                                do_exit();$&#10;&#10;#581: FILE: monit.c:581:&#10;+                        else if (Run.flags &amp;amp; Run_DoReload)$&#10;&#10;#582: FILE: monit.c:582:&#10;+                                do_reinit();$&#10;&#10;#583: FILE: monit.c:583:&#10;+                }$&#10;&#10;#584: FILE: monit.c:584:&#10;+        } else {$&#10;&#10;#585: FILE: monit.c:585:&#10;+                _validateOnce();$&#10;&#10;#586: FILE: monit.c:586:&#10;+        }$&#10;&#10;#595: FILE: monit.c:595:&#10;+        int opt;$&#10;&#10;#596: FILE: monit.c:596:&#10;+        int deferred_opt = 0;$&#10;&#10;#597: FILE: monit.c:597:&#10;+        opterr = 0;$&#10;&#10;#598: FILE: monit.c:598:&#10;+        Run.mygroup = NULL;$&#10;&#10;#599: FILE: monit.c:599:&#10;+        const char *shortopts = &quot;c:d:g:l:p:s:HIirtvVh&quot;;$&#10;&#10;#601: FILE: monit.c:601:&#10;+        struct option longopts[] = {$&#10;&#10;#602: FILE: monit.c:602:&#10;+                {&quot;conf&quot;,        required_argument,      NULL,   'c'},$&#10;&#10;#603: FILE: monit.c:603:&#10;+                {&quot;daemon&quot;,      required_argument,      NULL,   'd'},$&#10;&#10;#604: FILE: monit.c:604:&#10;+                {&quot;group&quot;,       required_argument,      NULL,   'g'},$&#10;&#10;#605: FILE: monit.c:605:&#10;+                {&quot;logfile&quot;,     required_argument,      NULL,   'l'},$&#10;&#10;#606: FILE: monit.c:606:&#10;+                {&quot;pidfile&quot;,     required_argument,      NULL,   'p'},$&#10;&#10;#607: FILE: monit.c:607:&#10;+                {&quot;statefile&quot;,   required_argument,      NULL,   's'},$&#10;&#10;#608: FILE: monit.c:608:&#10;+                {&quot;hash&quot;,        optional_argument,      NULL,   'H'},$&#10;&#10;#609: FILE: monit.c:609:&#10;+                {&quot;interactive&quot;, no_argument,            NULL,   'I'},$&#10;&#10;#610: FILE: monit.c:610:&#10;+                {&quot;id&quot;,          no_argument,            NULL,   'i'},$&#10;&#10;#611: FILE: monit.c:611:&#10;+                {&quot;resetid&quot;,     no_argument,            NULL,   'r'},$&#10;&#10;#612: FILE: monit.c:612:&#10;+                {&quot;test&quot;,        no_argument,            NULL,   't'},$&#10;&#10;#613: FILE: monit.c:613:&#10;+                {&quot;verbose&quot;,     no_argument,            NULL,   'v'},$&#10;&#10;#614: FILE: monit.c:614:&#10;+                {&quot;version&quot;,     no_argument,            NULL,   'V'},$&#10;&#10;#615: FILE: monit.c:615:&#10;+                {&quot;help&quot;,        no_argument,            NULL,   'h'},$&#10;&#10;#616: FILE: monit.c:616:&#10;+                {0}$&#10;&#10;#617: FILE: monit.c:617:&#10;+        };$&#10;&#10;#618: FILE: monit.c:618:&#10;+        while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)$&#10;&#10;#620: FILE: monit.c:620:&#10;+                while ((opt = getopt(argc, argv, shortopts)) != -1)$&#10;&#10;#622: FILE: monit.c:622:&#10;+                {$&#10;&#10;#623: FILE: monit.c:623:&#10;+                        switch (opt) {$&#10;&#10;#624: FILE: monit.c:624:&#10;+                                case 'c':$&#10;&#10;#625: FILE: monit.c:625:&#10;+                                {$&#10;&#10;#626: FILE: monit.c:626:&#10;+                                        char *f = optarg;$&#10;&#10;#627: FILE: monit.c:627:&#10;+                                        if (f[0] != SEPARATOR_CHAR)$&#10;&#10;#628: FILE: monit.c:628:&#10;+                                                f = File_getRealPath(optarg, (char[PATH_MAX]){});$&#10;&#10;#629: FILE: monit.c:629:&#10;+                                        if (! f)$&#10;&#10;#630: FILE: monit.c:630:&#10;+                                                THROW(AssertException, &quot;The control file '%s' does not exist at %s&quot;,$&#10;&#10;#631: FILE: monit.c:631:&#10;+                                                      Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));$&#10;&#10;#632: FILE: monit.c:632:&#10;+                                        if (! File_isFile(f))$&#10;&#10;#633: FILE: monit.c:633:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not a file&quot;, Str_trunc(f, 80));$&#10;&#10;#634: FILE: monit.c:634:&#10;+                                        if (! File_isReadable(f))$&#10;&#10;#635: FILE: monit.c:635:&#10;+                                                THROW(AssertException, &quot;The control file '%s' is not readable&quot;, Str_trunc(f, 80));$&#10;&#10;#636: FILE: monit.c:636:&#10;+                                        Run.files.control = Str_dup(f);$&#10;&#10;#637: FILE: monit.c:637:&#10;+                                        break;$&#10;&#10;#638: FILE: monit.c:638:&#10;+                                }$&#10;&#10;#639: FILE: monit.c:639:&#10;+                                case 'd':$&#10;&#10;#640: FILE: monit.c:640:&#10;+                                {$&#10;&#10;#641: FILE: monit.c:641:&#10;+                                        Run.flags |= Run_Daemon;$&#10;&#10;#642: FILE: monit.c:642:&#10;+                                        sscanf(optarg, &quot;%d&quot;, &amp;amp;Run.polltime);$&#10;&#10;#643: FILE: monit.c:643:&#10;+                                        if (Run.polltime &amp;lt; 1) {$&#10;&#10;#644: FILE: monit.c:644:&#10;+                                                LogError(&quot;Option -%c requires a natural number\n&quot;, opt);$&#10;&#10;#645: FILE: monit.c:645:&#10;+                                                exit(1);$&#10;&#10;#646: FILE: monit.c:646:&#10;+                                        }$&#10;&#10;#647: FILE: monit.c:647:&#10;+                                        break;$&#10;&#10;#648: FILE: monit.c:648:&#10;+                                }$&#10;&#10;#649: FILE: monit.c:649:&#10;+                                case 'g':$&#10;&#10;#650: FILE: monit.c:650:&#10;+                                {$&#10;&#10;#651: FILE: monit.c:651:&#10;+                                        Run.mygroup = Str_dup(optarg);$&#10;&#10;#652: FILE: monit.c:652:&#10;+                                        break;$&#10;&#10;#653: FILE: monit.c:653:&#10;+                                }$&#10;&#10;#654: FILE: monit.c:654:&#10;+                                case 'l':$&#10;&#10;#655: FILE: monit.c:655:&#10;+                                {$&#10;&#10;#656: FILE: monit.c:656:&#10;+                                        Run.files.log = Str_dup(optarg);$&#10;&#10;#657: FILE: monit.c:657:&#10;+                                        if (IS(Run.files.log, &quot;syslog&quot;))$&#10;&#10;#658: FILE: monit.c:658:&#10;+                                                Run.flags |= Run_UseSyslog;$&#10;&#10;#659: FILE: monit.c:659:&#10;+                                        Run.flags |= Run_Log;$&#10;&#10;#660: FILE: monit.c:660:&#10;+                                        break;$&#10;&#10;#661: FILE: monit.c:661:&#10;+                                }$&#10;&#10;#662: FILE: monit.c:662:&#10;+                                case 'p':$&#10;&#10;#663: FILE: monit.c:663:&#10;+                                {$&#10;&#10;#664: FILE: monit.c:664:&#10;+                                        Run.files.pid = Str_dup(optarg);$&#10;&#10;#665: FILE: monit.c:665:&#10;+                                        break;$&#10;&#10;#666: FILE: monit.c:666:&#10;+                                }$&#10;&#10;#667: FILE: monit.c:667:&#10;+                                case 's':$&#10;&#10;#668: FILE: monit.c:668:&#10;+                                {$&#10;&#10;#669: FILE: monit.c:669:&#10;+                                        Run.files.state = Str_dup(optarg);$&#10;&#10;#670: FILE: monit.c:670:&#10;+                                        break;$&#10;&#10;#671: FILE: monit.c:671:&#10;+                                }$&#10;&#10;#672: FILE: monit.c:672:&#10;+                                case 'I':$&#10;&#10;#673: FILE: monit.c:673:&#10;+                                {$&#10;&#10;#674: FILE: monit.c:674:&#10;+                                        Run.flags |= Run_Foreground;$&#10;&#10;#675: FILE: monit.c:675:&#10;+                                        break;$&#10;&#10;#676: FILE: monit.c:676:&#10;+                                }$&#10;&#10;#677: FILE: monit.c:677:&#10;+                                case 'i':$&#10;&#10;#678: FILE: monit.c:678:&#10;+                                {$&#10;&#10;#679: FILE: monit.c:679:&#10;+                                        deferred_opt = 'i';$&#10;&#10;#680: FILE: monit.c:680:&#10;+                                        break;$&#10;&#10;#681: FILE: monit.c:681:&#10;+                                }$&#10;&#10;#682: FILE: monit.c:682:&#10;+                                case 'r':$&#10;&#10;#683: FILE: monit.c:683:&#10;+                                {$&#10;&#10;#684: FILE: monit.c:684:&#10;+                                        deferred_opt = 'r';$&#10;&#10;#685: FILE: monit.c:685:&#10;+                                        break;$&#10;&#10;#686: FILE: monit.c:686:&#10;+                                }$&#10;&#10;#687: FILE: monit.c:687:&#10;+                                case 't':$&#10;&#10;#688: FILE: monit.c:688:&#10;+                                {$&#10;&#10;#689: FILE: monit.c:689:&#10;+                                        deferred_opt = 't';$&#10;&#10;#690: FILE: monit.c:690:&#10;+                                        break;$&#10;&#10;#691: FILE: monit.c:691:&#10;+                                }$&#10;&#10;#692: FILE: monit.c:692:&#10;+                                case 'v':$&#10;&#10;#693: FILE: monit.c:693:&#10;+                                {$&#10;&#10;#694: FILE: monit.c:694:&#10;+                                        Run.debug++;$&#10;&#10;#695: FILE: monit.c:695:&#10;+                                        break;$&#10;&#10;#696: FILE: monit.c:696:&#10;+                                }$&#10;&#10;#697: FILE: monit.c:697:&#10;+                                case 'H':$&#10;&#10;#698: FILE: monit.c:698:&#10;+                                {$&#10;&#10;#699: FILE: monit.c:699:&#10;+                                        if (argc &amp;gt; optind)$&#10;&#10;#700: FILE: monit.c:700:&#10;+                                                Util_printHash(argv[optind]);$&#10;&#10;#701: FILE: monit.c:701:&#10;+                                        else$&#10;&#10;#702: FILE: monit.c:702:&#10;+                                                Util_printHash(NULL);$&#10;&#10;#703: FILE: monit.c:703:&#10;+                                        exit(0);$&#10;&#10;#704: FILE: monit.c:704:&#10;+                                        break;$&#10;&#10;#705: FILE: monit.c:705:&#10;+                                }$&#10;&#10;#706: FILE: monit.c:706:&#10;+                                case 'V':$&#10;&#10;#707: FILE: monit.c:707:&#10;+                                {$&#10;&#10;#708: FILE: monit.c:708:&#10;+                                        version();$&#10;&#10;#709: FILE: monit.c:709:&#10;+                                        exit(0);$&#10;&#10;#710: FILE: monit.c:710:&#10;+                                        break;$&#10;&#10;#711: FILE: monit.c:711:&#10;+                                }$&#10;&#10;#712: FILE: monit.c:712:&#10;+                                case 'h':$&#10;&#10;#713: FILE: monit.c:713:&#10;+                                {$&#10;&#10;#714: FILE: monit.c:714:&#10;+                                        help();$&#10;&#10;#715: FILE: monit.c:715:&#10;+                                        exit(0);$&#10;&#10;#716: FILE: monit.c:716:&#10;+                                        break;$&#10;&#10;#717: FILE: monit.c:717:&#10;+                                }$&#10;&#10;#718: FILE: monit.c:718:&#10;+                                case '?':$&#10;&#10;#719: FILE: monit.c:719:&#10;+                                {$&#10;&#10;#720: FILE: monit.c:720:&#10;+                                        switch (optopt) {$&#10;&#10;#721: FILE: monit.c:721:&#10;+                                                case 'c':$&#10;&#10;#722: FILE: monit.c:722:&#10;+                                                case 'd':$&#10;&#10;#723: FILE: monit.c:723:&#10;+                                                case 'g':$&#10;&#10;#724: FILE: monit.c:724:&#10;+                                                case 'l':$&#10;&#10;#725: FILE: monit.c:725:&#10;+                                                case 'p':$&#10;&#10;#726: FILE: monit.c:726:&#10;+                                                case 's':$&#10;&#10;#727: FILE: monit.c:727:&#10;+                                                {$&#10;&#10;#728: FILE: monit.c:728:&#10;+                                                        LogError(&quot;Option -- %c requires an argument\n&quot;, optopt);$&#10;&#10;#729: FILE: monit.c:729:&#10;+                                                        break;$&#10;&#10;#730: FILE: monit.c:730:&#10;+                                                }$&#10;&#10;#732: FILE: monit.c:732:&#10;+                                                {$&#10;&#10;#733: FILE: monit.c:733:&#10;+                                                        LogError(&quot;Invalid option -- %c  (-h will show valid options)\n&quot;, optopt);$&#10;&#10;#734: FILE: monit.c:734:&#10;+                                                }$&#10;&#10;#735: FILE: monit.c:735:&#10;+                                        }$&#10;&#10;#736: FILE: monit.c:736:&#10;+                                        exit(1);$&#10;&#10;#737: FILE: monit.c:737:&#10;+                                }$&#10;&#10;#738: FILE: monit.c:738:&#10;+                        }$&#10;&#10;#739: FILE: monit.c:739:&#10;+                }$&#10;&#10;#745: FILE: monit.c:745:&#10;+        switch (deferred_opt) {$&#10;&#10;#746: FILE: monit.c:746:&#10;+                case 't':$&#10;&#10;#747: FILE: monit.c:747:&#10;+                {$&#10;&#10;#748: FILE: monit.c:748:&#10;+                        do_init(); // Parses control file and initialize program, exit on error$&#10;&#10;#749: FILE: monit.c:749:&#10;+                        printf(&quot;Control file syntax OK\n&quot;);$&#10;&#10;#750: FILE: monit.c:750:&#10;+                        exit(0);$&#10;&#10;#751: FILE: monit.c:751:&#10;+                        break;$&#10;&#10;#752: FILE: monit.c:752:&#10;+                }$&#10;&#10;#753: FILE: monit.c:753:&#10;+                case 'r':$&#10;&#10;#754: FILE: monit.c:754:&#10;+                {$&#10;&#10;#755: FILE: monit.c:755:&#10;+                        do_init();$&#10;&#10;#756: FILE: monit.c:756:&#10;+                        assert(Run.id);$&#10;&#10;#757: FILE: monit.c:757:&#10;+                        printf(&quot;Reset Monit Id? [y/n]&amp;gt; &quot;);$&#10;&#10;#758: FILE: monit.c:758:&#10;+                        if ( getchar() == 'y') {$&#10;&#10;#759: FILE: monit.c:759:&#10;+                                File_delete(Run.files.id);$&#10;&#10;#760: FILE: monit.c:760:&#10;+                                Util_monitId(Run.files.id);$&#10;&#10;#761: FILE: monit.c:761:&#10;+                                kill_daemon(SIGHUP); // make any running Monit Daemon reload the new ID-File$&#10;&#10;#762: FILE: monit.c:762:&#10;+                        }$&#10;&#10;#763: FILE: monit.c:763:&#10;+                        exit(0);$&#10;&#10;#764: FILE: monit.c:764:&#10;+                        break;$&#10;&#10;#765: FILE: monit.c:765:&#10;+                }$&#10;&#10;#766: FILE: monit.c:766:&#10;+                case 'i':$&#10;&#10;#767: FILE: monit.c:767:&#10;+                {$&#10;&#10;#768: FILE: monit.c:768:&#10;+                        do_init();$&#10;&#10;#769: FILE: monit.c:769:&#10;+                        assert(Run.id);$&#10;&#10;#770: FILE: monit.c:770:&#10;+                        printf(&quot;Monit ID: %s\n&quot;, Run.id);$&#10;&#10;#771: FILE: monit.c:771:&#10;+                        exit(0);$&#10;&#10;#772: FILE: monit.c:772:&#10;+                        break;$&#10;&#10;#773: FILE: monit.c:773:&#10;+                }$&#10;&#10;#774: FILE: monit.c:774:&#10;+        }$&#10;&#10;#782: FILE: monit.c:782:&#10;+        printf(&quot;Usage: %s [options]+ [command]\n&quot;, prog);$&#10;&#10;#783: FILE: monit.c:783:&#10;+        printf(&quot;Options are as follows:\n&quot;);$&#10;&#10;#784: FILE: monit.c:784:&#10;+        printf(&quot; -c file       Use this control file\n&quot;);$&#10;&#10;#785: FILE: monit.c:785:&#10;+        printf(&quot; -d n          Run as a daemon once per n seconds\n&quot;);$&#10;&#10;#786: FILE: monit.c:786:&#10;+        printf(&quot; -g name       Set group name for monit commands\n&quot;);$&#10;&#10;#787: FILE: monit.c:787:&#10;+        printf(&quot; -l logfile    Print log information to this file\n&quot;);$&#10;&#10;#788: FILE: monit.c:788:&#10;+        printf(&quot; -p pidfile    Use this lock file in daemon mode\n&quot;);$&#10;&#10;#789: FILE: monit.c:789:&#10;+        printf(&quot; -s statefile  Set the file monit should write state information to\n&quot;);$&#10;&#10;#790: FILE: monit.c:790:&#10;+        printf(&quot; -I            Do not run in background (needed for run from init)\n&quot;);$&#10;&#10;#791: FILE: monit.c:791:&#10;+        printf(&quot; --id          Print Monit's unique ID\n&quot;);$&#10;&#10;#792: FILE: monit.c:792:&#10;+        printf(&quot; --resetid     Reset Monit's unique ID. Use with caution\n&quot;);$&#10;&#10;#793: FILE: monit.c:793:&#10;+        printf(&quot; -t            Run syntax check for the control file\n&quot;);$&#10;&#10;#794: FILE: monit.c:794:&#10;+        printf(&quot; -v            Verbose mode, work noisy (diagnostic output)\n&quot;);$&#10;&#10;#795: FILE: monit.c:795:&#10;+        printf(&quot; -vv           Very verbose mode, same as -v plus log stacktrace on error\n&quot;);$&#10;&#10;#796: FILE: monit.c:796:&#10;+        printf(&quot; -H [filename] Print SHA1 and MD5 hashes of the file or of stdin if the\n&quot;);$&#10;&#10;#797: FILE: monit.c:797:&#10;+        printf(&quot;               filename is omited; monit will exit afterwards\n&quot;);$&#10;&#10;#798: FILE: monit.c:798:&#10;+        printf(&quot; -V            Print version number and patchlevel\n&quot;);$&#10;&#10;#799: FILE: monit.c:799:&#10;+        printf(&quot; -h            Print this text\n&quot;);$&#10;&#10;#800: FILE: monit.c:800:&#10;+        printf(&quot;Optional commands are as follows:\n&quot;);$&#10;&#10;#801: FILE: monit.c:801:&#10;+        printf(&quot; start all           - Start all services\n&quot;);$&#10;&#10;#802: FILE: monit.c:802:&#10;+        printf(&quot; start &amp;lt;name&amp;gt;        - Only start the named service\n&quot;);$&#10;&#10;#803: FILE: monit.c:803:&#10;+        printf(&quot; stop all            - Stop all services\n&quot;);$&#10;&#10;#804: FILE: monit.c:804:&#10;+        printf(&quot; stop &amp;lt;name&amp;gt;         - Only stop the named service\n&quot;);$&#10;&#10;#805: FILE: monit.c:805:&#10;+        printf(&quot; restart all         - Stop and start all services\n&quot;);$&#10;&#10;#806: FILE: monit.c:806:&#10;+        printf(&quot; restart &amp;lt;name&amp;gt;      - Only restart the named service\n&quot;);$&#10;&#10;#807: FILE: monit.c:807:&#10;+        printf(&quot; monitor all         - Enable monitoring of all services\n&quot;);$&#10;&#10;#808: FILE: monit.c:808:&#10;+        printf(&quot; monitor &amp;lt;name&amp;gt;      - Only enable monitoring of the named service\n&quot;);$&#10;&#10;#809: FILE: monit.c:809:&#10;+        printf(&quot; unmonitor all       - Disable monitoring of all services\n&quot;);$&#10;&#10;#810: FILE: monit.c:810:&#10;+        printf(&quot; unmonitor &amp;lt;name&amp;gt;    - Only disable monitoring of the named service\n&quot;);$&#10;&#10;#811: FILE: monit.c:811:&#10;+        printf(&quot; reload              - Reinitialize monit\n&quot;);$&#10;&#10;#812: FILE: monit.c:812:&#10;+        printf(&quot; status [name]       - Print full status information for service(s)\n&quot;);$&#10;&#10;#813: FILE: monit.c:813:&#10;+        printf(&quot; summary [name]      - Print short status information for service(s)\n&quot;);$&#10;&#10;#814: FILE: monit.c:814:&#10;+        printf(&quot; quit                - Kill monit daemon process\n&quot;);$&#10;&#10;#815: FILE: monit.c:815:&#10;+        printf(&quot; validate            - Check all services and start if not running\n&quot;);$&#10;&#10;#816: FILE: monit.c:816:&#10;+        printf(&quot; procmatch &amp;lt;pattern&amp;gt; - Test process matching pattern\n&quot;);$&#10;&#10;#817: FILE: monit.c:817:&#10;+        printf(&quot;\n&quot;);$&#10;&#10;#818: FILE: monit.c:818:&#10;+        printf(&quot;(Action arguments operate on services defined in the control file)\n&quot;);$&#10;&#10;#825: FILE: monit.c:825:&#10;+        printf(&quot;This is Monit version %s\n&quot;, VERSION);$&#10;&#10;#826: FILE: monit.c:826:&#10;+        printf(&quot;Built with&quot;);$&#10;&#10;#828: FILE: monit.c:828:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#830: FILE: monit.c:830:&#10;+        printf(&quot; ssl, with&quot;);$&#10;&#10;#832: FILE: monit.c:832:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#834: FILE: monit.c:834:&#10;+        printf(&quot; pam and with&quot;);$&#10;&#10;#836: FILE: monit.c:836:&#10;+        printf(&quot;out&quot;);$&#10;&#10;#838: FILE: monit.c:838:&#10;+        printf(&quot; large files\n&quot;);$&#10;&#10;#839: FILE: monit.c:839:&#10;+        printf(&quot;Copyright (C) 2001-2016 Tildeslash Ltd. All Rights Reserved.\n&quot;);$&#10;&#10;#847: FILE: monit.c:847:&#10;+        set_signal_block();$&#10;&#10;#848: FILE: monit.c:848:&#10;+        LogInfo(&quot;M/Monit heartbeat started\n&quot;);$&#10;&#10;#849: FILE: monit.c:849:&#10;+        LOCK(heartbeatMutex)$&#10;&#10;#850: FILE: monit.c:850:&#10;+        {$&#10;&#10;#851: FILE: monit.c:851:&#10;+                while (! (Run.flags &amp;amp; Run_Stopped) &amp;amp;&amp;amp; ! (Run.flags &amp;amp; Run_DoReload)) {$&#10;&#10;#852: FILE: monit.c:852:&#10;+                        handle_mmonit(NULL);$&#10;&#10;#853: FILE: monit.c:853:&#10;+                        struct timespec wait = {.tv_sec = Time_now() + Run.polltime, .tv_nsec = 0};$&#10;&#10;#854: FILE: monit.c:854:&#10;+                        Sem_timeWait(heartbeatCond, heartbeatMutex, wait);$&#10;&#10;#855: FILE: monit.c:855:&#10;+                }$&#10;&#10;#856: FILE: monit.c:856:&#10;+        }$&#10;&#10;#857: FILE: monit.c:857:&#10;+        END_LOCK;$&#10;&#10;#859: FILE: monit.c:859:&#10;+        Ssl_threadCleanup();$&#10;&#10;#861: FILE: monit.c:861:&#10;+        LogInfo(&quot;M/Monit heartbeat stopped\n&quot;);$&#10;&#10;#862: FILE: monit.c:862:&#10;+        return NULL;$&#10;&#10;#870: FILE: monit.c:870:&#10;+        Run.flags |= Run_DoReload;$&#10;&#10;#878: FILE: monit.c:878:&#10;+        Run.flags |= Run_Stopped;$&#10;&#10;#886: FILE: monit.c:886:&#10;+        Run.flags |= Run_DoWakeup;$&#10;&#10;#893: FILE: monit.c:893:&#10;+        while (waitpid(-1, NULL, WNOHANG) &amp;gt; 0) ;$&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="SPACING">
  <failure type="SPACING">SPACING</failure>
  <system-err>
space prohibited before semicolon&#10;#893: FILE: monit.c:893:&#10;+        while (waitpid(-1, NULL, WNOHANG) &amp;gt; 0) ;&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.WARNING" name="NAKED_SSCANF">
  <failure type="NAKED_SSCANF">NAKED_SSCANF</failure>
  <system-err>
'unchecked sscanf return value&#10;#642: FILE: monit.c:642:&#10;+                                        sscanf(optarg, "%d", &amp;amp;Run.polltime);&#10;&#10;'

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="GLOBAL_INITIALISERS">
  <failure type="GLOBAL_INITIALISERS">GLOBAL_INITIALISERS</failure>
  <system-err>
do not initialise globals to 0&#10;#134: FILE: monit.c:134:&#10;+int ptreesize = 0;&#10;&#10;#135: FILE: monit.c:135:&#10;+ProcessTree_T *ptree = NULL;&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="OPEN_BRACE">
  <failure type="OPEN_BRACE">OPEN_BRACE</failure>
  <system-err>
open brace '{' following function declarations go on the next line&#10;#155: FILE: monit.c:155:&#10;+int main(int argc, char **argv) {&#10;&#10;#177: FILE: monit.c:177:&#10;+boolean_t do_wakeupcall() {&#10;&#10;#194: FILE: monit.c:194:&#10;+static void _validateOnce() {&#10;&#10;#209: FILE: monit.c:209:&#10;+static void do_init() {&#10;&#10;#319: FILE: monit.c:319:&#10;+static void do_reinit() {&#10;&#10;#399: FILE: monit.c:399:&#10;+static void do_action(char **args) {&#10;&#10;#477: FILE: monit.c:477:&#10;+static void do_exit() {&#10;&#10;#508: FILE: monit.c:508:&#10;+static void do_default() {&#10;&#10;#594: FILE: monit.c:594:&#10;+static void handle_options(int argc, char **argv) {&#10;&#10;#781: FILE: monit.c:781:&#10;+static void help() {&#10;&#10;#824: FILE: monit.c:824:&#10;+static void version() {&#10;&#10;#846: FILE: monit.c:846:&#10;+static void *heartbeat(void *args) {&#10;&#10;#869: FILE: monit.c:869:&#10;+static RETSIGTYPE do_reload(int sig) {&#10;&#10;#877: FILE: monit.c:877:&#10;+static RETSIGTYPE do_destroy(int sig) {&#10;&#10;#885: FILE: monit.c:885:&#10;+static RETSIGTYPE do_wakeup(int sig) {&#10;&#10;#892: FILE: monit.c:892:&#10;+static void waitforchildren(void) {&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="FUNCTION_WITHOUT_ARGS">
  <failure type="FUNCTION_WITHOUT_ARGS">FUNCTION_WITHOUT_ARGS</failure>
  <system-err>
Bad function definition - void  do_init() should probably be void  do_init(void)&#10;#103: FILE: monit.c:103:&#10;+static void  do_init();                       /* Initialize this application */&#10;&#10;#104: FILE: monit.c:104:&#10;+static void  do_reinit();           /* Re-initialize the runtime application */&#10;&#10;#106: FILE: monit.c:106:&#10;+static void  do_exit();                                    /* Finalize monit */&#10;&#10;#107: FILE: monit.c:107:&#10;+static void  do_default();                              /* Do default action */&#10;&#10;#109: FILE: monit.c:109:&#10;+static void  help();                 /* Print program help message to stdout */&#10;&#10;#110: FILE: monit.c:110:&#10;+static void  version();                         /* Print version information */&#10;&#10;#177: FILE: monit.c:177:&#10;+boolean_t do_wakeupcall() {&#10;&#10;#194: FILE: monit.c:194:&#10;+static void _validateOnce() {&#10;&#10;#209: FILE: monit.c:209:&#10;+static void do_init() {&#10;&#10;#319: FILE: monit.c:319:&#10;+static void do_reinit() {&#10;&#10;#477: FILE: monit.c:477:&#10;+static void do_exit() {&#10;&#10;#508: FILE: monit.c:508:&#10;+static void do_default() {&#10;&#10;#781: FILE: monit.c:781:&#10;+static void help() {&#10;&#10;#824: FILE: monit.c:824:&#10;+static void version() {&#10;&#10;

  </system-err>
 </testcase>
 <testcase classname="CHECKPATCH.ERROR" name="ASSIGN_IN_IF">
  <failure type="ASSIGN_IN_IF">ASSIGN_IN_IF</failure>
  <system-err>
do not use assignment in if condition&#10;#180: FILE: monit.c:180:&#10;+        if ((pid = exist_daemon()) &amp;gt; 0) {&#10;&#10;

  </system-err>
 </testcase>
</testsuite>
